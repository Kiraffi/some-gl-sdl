#!#![allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals)]

use std::mem;
use std::os::raw::*;

pub type VkSampleMask = u32;
pub type VkBool32 = u32;
pub type VkFlags = u32;
pub type VkFlags64 = u64;
pub type VkDeviceSize = u64;
pub type VkDeviceAddress = u64;

pub type VkClearValue = f32;

pub fn vk_make_version(variant: u32, major: u32, minor: u32, patch: u32) -> u32
{
    return (variant << 29) | (major << 22) | (minor << 12) | patch;
}

pub type VkInstance = u64;
pub type VkPhysicalDevice = u64;
pub type VkDevice = u64;
pub type VkQueue = u64;
pub type VkCommandBuffer = u64;
pub type VkDeviceMemory = u64;
pub type VkCommandPool = u64;
pub type VkBuffer = u64;
pub type VkBufferView = u64;
pub type VkImage = u64;
pub type VkImageView = u64;
pub type VkShaderModule = u64;
pub type VkPipeline = u64;
pub type VkPipelineLayout = u64;
pub type VkSampler = u64;
pub type VkDescriptorSet = u64;
pub type VkDescriptorSetLayout = u64;
pub type VkDescriptorPool = u64;
pub type VkFence = u64;
pub type VkSemaphore = u64;
pub type VkEvent = u64;
pub type VkQueryPool = u64;
pub type VkFramebuffer = u64;
pub type VkRenderPass = u64;
pub type VkPipelineCache = u64;
pub type VkIndirectCommandsLayoutNV = u64;
pub type VkDescriptorUpdateTemplate = u64;
pub type VkSamplerYcbcrConversion = u64;
pub type VkValidationCacheEXT = u64;
pub type VkAccelerationStructureKHR = u64;
pub type VkAccelerationStructureNV = u64;
pub type VkPerformanceConfigurationINTEL = u64;
pub type VkDeferredOperationKHR = u64;
pub type VkPrivateDataSlotEXT = u64;
pub type VkCuModuleNVX = u64;
pub type VkCuFunctionNVX = u64;
pub type VkDisplayKHR = u64;
pub type VkDisplayModeKHR = u64;
pub type VkSurfaceKHR = u64;
pub type VkSwapchainKHR = u64;
pub type VkDebugReportCallbackEXT = u64;
pub type VkDebugUtilsMessengerEXT = u64;
pub type VkVideoSessionKHR = u64;
pub type VkVideoSessionParametersKHR = u64;


pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE:usize = 256;
pub const VK_UUID_SIZE:usize = 16;
pub const VK_LUID_SIZE:usize = 8;
pub const VK_MAX_EXTENSION_NAME_SIZE:usize = 256;
pub const VK_MAX_DESCRIPTION_SIZE:usize = 256;
pub const VK_MAX_MEMORY_TYPES:usize = 32;
pub const VK_MAX_MEMORY_HEAPS:usize = 16;
pub const VK_LOD_CLAMP_NONE:f32 = 1000.0f32;
pub const VK_REMAINING_MIP_LEVELS:u32 = !0u32;
pub const VK_REMAINING_ARRAY_LAYERS:u32 = !0u32;
pub const VK_WHOLE_SIZE:u64 = !0u64;
pub const VK_ATTACHMENT_UNUSED:u32 = !0u32;
pub const VK_TRUE:usize = 1;
pub const VK_FALSE:usize = 0;
pub const VK_QUEUE_FAMILY_IGNORED:u32 = !0u32;
pub const VK_QUEUE_FAMILY_EXTERNAL:u32 = !1u32;
pub const VK_QUEUE_FAMILY_FOREIGN_EXT:u32 = !2u32;
pub const VK_SUBPASS_EXTERNAL:u32 = !0u32;
pub const VK_MAX_DEVICE_GROUP_SIZE:usize = 32;
pub const VK_MAX_DRIVER_NAME_SIZE:usize = 256;
pub const VK_MAX_DRIVER_INFO_SIZE:usize = 256;
pub const VK_SHADER_UNUSED_KHR:u32 = !0u32;
pub const VK_MAX_GLOBAL_PRIORITY_SIZE_EXT:usize = 16;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageLayout
{
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAttachmentLoadOp
{
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAttachmentStoreOp
{
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_NONE_EXT = 1000301000,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageType
{
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageTiling
{
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageViewType
{
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandBufferLevel
{
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkComponentSwizzle
{
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorType
{
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryType
{
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBorderColor
{
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineBindPoint
{
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
    VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineCacheHeaderVersion
{
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
}

type VkPipelineCacheCreateFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPrimitiveTopology
{
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSharingMode
{
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkIndexType
{
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_NONE_KHR = 1000165000,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFilter
{
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerMipmapMode
{
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerAddressMode
{
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCompareOp
{
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPolygonMode
{
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFrontFace
{
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBlendFactor
{
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBlendOp
{
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkStencilOp
{
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkLogicOp
{
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkInternalAllocationType
{
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSystemAllocationScope
{
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPhysicalDeviceType
{
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVertexInputRate
{
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFormat
{
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
    VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT = 1000288000,
    VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT = 1000288001,
    VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT = 1000288002,
    VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT = 1000288003,
    VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT = 1000288004,
    VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT = 1000288005,
    VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT = 1000288006,
    VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT = 1000288007,
    VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT = 1000288008,
    VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT = 1000288009,
    VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT = 1000288010,
    VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT = 1000288011,
    VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT = 1000288012,
    VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT = 1000288013,
    VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT = 1000288014,
    VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT = 1000288015,
    VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT = 1000288016,
    VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT = 1000288017,
    VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT = 1000288018,
    VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT = 1000288019,
    VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT = 1000288020,
    VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT = 1000288021,
    VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT = 1000288022,
    VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT = 1000288023,
    VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT = 1000288024,
    VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT = 1000288025,
    VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT = 1000288026,
    VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT = 1000288027,
    VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT = 1000288028,
    VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT = 1000288029,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkStructureType
{
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSubpassContents
{
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkResult
{
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_UNKNOWN = -13,
    VK_ERROR_OUT_OF_POOL_MEMORY = 1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE = 1000072003,
    VK_ERROR_FRAGMENTATION = 1000161000,
    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = 1000257000,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDynamicState
{
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorUpdateTemplateType
{
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkObjectType
{
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueueFlagBits
{
    VK_QUEUE_GRAPHICS_BIT = 1,
    VK_QUEUE_COMPUTE_BIT = 2,
    VK_QUEUE_TRANSFER_BIT = 4,
    VK_QUEUE_SPARSE_BINDING_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCullModeFlagBits
{
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 1,
    VK_CULL_MODE_BACK_BIT = 2,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
}

type VkRenderPassCreateFlagBits = u32;

type VkDeviceQueueCreateFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkMemoryPropertyFlagBits
{
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 4,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 8,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkMemoryHeapFlagBits
{
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccessFlagBits
{
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1,
    VK_ACCESS_INDEX_READ_BIT = 2,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4,
    VK_ACCESS_UNIFORM_READ_BIT = 8,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16,
    VK_ACCESS_SHADER_READ_BIT = 32,
    VK_ACCESS_SHADER_WRITE_BIT = 64,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
    VK_ACCESS_TRANSFER_READ_BIT = 2048,
    VK_ACCESS_TRANSFER_WRITE_BIT = 4096,
    VK_ACCESS_HOST_READ_BIT = 8192,
    VK_ACCESS_HOST_WRITE_BIT = 16384,
    VK_ACCESS_MEMORY_READ_BIT = 32768,
    VK_ACCESS_MEMORY_WRITE_BIT = 65536,
    VK_ACCESS_NONE_KHR = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBufferUsageFlagBits
{
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 2,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 32,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 64,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 128,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBufferCreateFlagBits
{
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderStageFlagBits
{
    VK_SHADER_STAGE_VERTEX_BIT = 1,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4,
    VK_SHADER_STAGE_GEOMETRY_BIT = 8,
    VK_SHADER_STAGE_FRAGMENT_BIT = 16,
    VK_SHADER_STAGE_COMPUTE_BIT = 32,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageUsageFlagBits
{
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2,
    VK_IMAGE_USAGE_SAMPLED_BIT = 4,
    VK_IMAGE_USAGE_STORAGE_BIT = 8,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageCreateFlagBits
{
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 8,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 16,
}

type VkImageViewCreateFlagBits = u32;

type VkSamplerCreateFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineCreateFlagBits
{
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 2,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 4,
}

type VkPipelineShaderStageCreateFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkColorComponentFlagBits
{
    VK_COLOR_COMPONENT_R_BIT = 1,
    VK_COLOR_COMPONENT_G_BIT = 2,
    VK_COLOR_COMPONENT_B_BIT = 4,
    VK_COLOR_COMPONENT_A_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFenceCreateFlagBits
{
    VK_FENCE_CREATE_SIGNALED_BIT = 1,
}

type VkSemaphoreCreateFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFormatFeatureFlagBits
{
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 2,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 4,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 8,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 16,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 64,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 128,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 256,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 512,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1024,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 2048,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryControlFlagBits
{
    VK_QUERY_CONTROL_PRECISE_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryResultFlagBits
{
    VK_QUERY_RESULT_64_BIT = 1,
    VK_QUERY_RESULT_WAIT_BIT = 2,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 4,
    VK_QUERY_RESULT_PARTIAL_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandBufferUsageFlagBits
{
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryPipelineStatisticFlagBits
{
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 4,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 32,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 64,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 512,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1024,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageAspectFlagBits
{
    VK_IMAGE_ASPECT_COLOR_BIT = 1,
    VK_IMAGE_ASPECT_DEPTH_BIT = 2,
    VK_IMAGE_ASPECT_STENCIL_BIT = 4,
    VK_IMAGE_ASPECT_METADATA_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSparseImageFormatFlagBits
{
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 2,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSparseMemoryBindFlagBits
{
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineStageFlagBits
{
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 2,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 4,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 8,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 16,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 32,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 64,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 128,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 256,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 512,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 2048,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 4096,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 8192,
    VK_PIPELINE_STAGE_HOST_BIT = 16384,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 32768,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 65536,
    VK_PIPELINE_STAGE_NONE_KHR = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandPoolCreateFlagBits
{
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandPoolResetFlagBits
{
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandBufferResetFlagBits
{
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSampleCountFlagBits
{
    VK_SAMPLE_COUNT_1_BIT = 1,
    VK_SAMPLE_COUNT_2_BIT = 2,
    VK_SAMPLE_COUNT_4_BIT = 4,
    VK_SAMPLE_COUNT_8_BIT = 8,
    VK_SAMPLE_COUNT_16_BIT = 16,
    VK_SAMPLE_COUNT_32_BIT = 32,
    VK_SAMPLE_COUNT_64_BIT = 64,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAttachmentDescriptionFlagBits
{
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkStencilFaceFlagBits
{
    VK_STENCIL_FACE_FRONT_BIT = 1,
    VK_STENCIL_FACE_BACK_BIT = 2,
    VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorPoolCreateFlagBits
{
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDependencyFlagBits
{
    VK_DEPENDENCY_BY_REGION_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSemaphoreType
{
    VK_SEMAPHORE_TYPE_BINARY = 0,
    VK_SEMAPHORE_TYPE_TIMELINE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSemaphoreWaitFlagBits
{
    VK_SEMAPHORE_WAIT_ANY_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPresentModeKHR
{
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkColorSpaceKHR
{
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDisplayPlaneAlphaFlagBitsKHR
{
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 2,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 4,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCompositeAlphaFlagBitsKHR
{
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 2,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 4,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSurfaceTransformFlagBitsKHR
{
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 2,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 4,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 8,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 16,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 256,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSwapchainImageUsageFlagBitsANDROID
{
    VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkTimeDomainEXT
{
    VK_TIME_DOMAIN_DEVICE_EXT = 0,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2,
    VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDebugReportFlagBitsEXT
{
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 2,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 4,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 8,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDebugReportObjectTypeEXT
{
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceMemoryReportEventTypeEXT
{
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkRasterizationOrderAMD
{
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalMemoryHandleTypeFlagBitsNV
{
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 2,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 4,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalMemoryFeatureFlagBitsNV
{
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 1,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 2,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkValidationCheckEXT
{
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkValidationFeatureEnableEXT
{
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
    VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
    VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
    VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkValidationFeatureDisableEXT
{
    VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
    VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
    VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
    VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
    VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
    VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
    VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
    VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSubgroupFeatureFlagBits
{
    VK_SUBGROUP_FEATURE_BASIC_BIT = 1,
    VK_SUBGROUP_FEATURE_VOTE_BIT = 2,
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 4,
    VK_SUBGROUP_FEATURE_BALLOT_BIT = 8,
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 16,
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 32,
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 64,
    VK_SUBGROUP_FEATURE_QUAD_BIT = 128,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkIndirectCommandsLayoutUsageFlagBitsNV
{
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 1,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 2,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkIndirectStateFlagBitsNV
{
    VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkIndirectCommandsTokenTypeNV
{
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
}

type VkPrivateDataSlotCreateFlagBitsEXT = u32;

type VkDescriptorSetLayoutCreateFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalMemoryHandleTypeFlagBits
{
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 8,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 16,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 32,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 64,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalMemoryFeatureFlagBits
{
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 1,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 2,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalSemaphoreHandleTypeFlagBits
{
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 8,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalSemaphoreFeatureFlagBits
{
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 1,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSemaphoreImportFlagBits
{
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalFenceHandleTypeFlagBits
{
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalFenceFeatureFlagBits
{
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 1,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFenceImportFlagBits
{
    VK_FENCE_IMPORT_TEMPORARY_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSurfaceCounterFlagBitsEXT
{
    VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDisplayPowerStateEXT
{
    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceEventTypeEXT
{
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDisplayEventTypeEXT
{
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPeerMemoryFeatureFlagBits
{
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 1,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 2,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 4,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkMemoryAllocateFlagBits
{
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceGroupPresentModeFlagBitsKHR
{
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 1,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 2,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 4,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 8,
}

type VkSwapchainCreateFlagBitsKHR = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkViewportCoordinateSwizzleNV
{
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDiscardRectangleModeEXT
{
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
}

type VkSubpassDescriptionFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPointClippingBehavior
{
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerReductionMode
{
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
    VK_SAMPLER_REDUCTION_MODE_MIN = 1,
    VK_SAMPLER_REDUCTION_MODE_MAX = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkTessellationDomainOrigin
{
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerYcbcrModelConversion
{
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerYcbcrRange
{
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkChromaLocation
{
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    VK_CHROMA_LOCATION_MIDPOINT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBlendOverlapEXT
{
    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCoverageModulationModeNV
{
    VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
    VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCoverageReductionModeNV
{
    VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
    VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkValidationCacheHeaderVersionEXT
{
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderInfoTypeAMD
{
    VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
    VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueueGlobalPriorityEXT
{
    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128,
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256,
    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512,
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDebugUtilsMessageSeverityFlagBitsEXT
{
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 1,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 16,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 256,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 4096,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDebugUtilsMessageTypeFlagBitsEXT
{
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 1,
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 2,
    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkConservativeRasterizationModeEXT
{
    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorBindingFlagBits
{
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 1,
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 2,
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 4,
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVendorId
{
    VK_VENDOR_ID_VIV = 0x10001,
    VK_VENDOR_ID_VSI = 0x10002,
    VK_VENDOR_ID_KAZAN = 0x10003,
    VK_VENDOR_ID_CODEPLAY = 0x10004,
    VK_VENDOR_ID_MESA = 0x10005,
    VK_VENDOR_ID_POCL = 0x10006,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDriverId
{
    VK_DRIVER_ID_AMD_PROPRIETARY = 1,
    VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
    VK_DRIVER_ID_MESA_RADV = 3,
    VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
    VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
    VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
    VK_DRIVER_ID_ARM_PROPRIETARY = 9,
    VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
    VK_DRIVER_ID_GGP_PROPRIETARY = 11,
    VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
    VK_DRIVER_ID_MESA_LLVMPIPE = 13,
    VK_DRIVER_ID_MOLTENVK = 14,
    VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
    VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
    VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
    VK_DRIVER_ID_MESA_TURNIP = 18,
    VK_DRIVER_ID_MESA_V3DV = 19,
    VK_DRIVER_ID_MESA_PANVK = 20,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkConditionalRenderingFlagBitsEXT
{
    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkResolveModeFlagBits
{
    VK_RESOLVE_MODE_NONE = 0,
    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 1,
    VK_RESOLVE_MODE_AVERAGE_BIT = 2,
    VK_RESOLVE_MODE_MIN_BIT = 4,
    VK_RESOLVE_MODE_MAX_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShadingRatePaletteEntryNV
{
    VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
    VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
    VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
    VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
    VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCoarseSampleOrderTypeNV
{
    VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
    VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
    VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
    VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkGeometryInstanceFlagBitsKHR
{
    VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 1,
    VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 2,
    VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 4,
    VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkGeometryFlagBitsKHR
{
    VK_GEOMETRY_OPAQUE_BIT_KHR = 1,
    VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBuildAccelerationStructureFlagBitsKHR
{
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 1,
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 2,
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 4,
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 8,
    VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureCreateFlagBitsKHR
{
    VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCopyAccelerationStructureModeKHR
{
    VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBuildAccelerationStructureModeKHR
{
    VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
    VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureTypeKHR
{
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
    VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkGeometryTypeKHR
{
    VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
    VK_GEOMETRY_TYPE_AABBS_KHR = 1,
    VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureMemoryRequirementsTypeNV
{
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureBuildTypeKHR
{
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkRayTracingShaderGroupTypeKHR
{
    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureCompatibilityKHR
{
    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderGroupShaderKHR
{
    VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
    VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
    VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
    VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkMemoryOverallocationBehaviorAMD
{
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
}

type VkFramebufferCreateFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkScopeNV
{
    VK_SCOPE_DEVICE_NV = 1,
    VK_SCOPE_WORKGROUP_NV = 2,
    VK_SCOPE_SUBGROUP_NV = 3,
    VK_SCOPE_QUEUE_FAMILY_NV = 5,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkComponentTypeNV
{
    VK_COMPONENT_TYPE_FLOAT16_NV = 0,
    VK_COMPONENT_TYPE_FLOAT32_NV = 1,
    VK_COMPONENT_TYPE_FLOAT64_NV = 2,
    VK_COMPONENT_TYPE_SINT8_NV = 3,
    VK_COMPONENT_TYPE_SINT16_NV = 4,
    VK_COMPONENT_TYPE_SINT32_NV = 5,
    VK_COMPONENT_TYPE_SINT64_NV = 6,
    VK_COMPONENT_TYPE_UINT8_NV = 7,
    VK_COMPONENT_TYPE_UINT16_NV = 8,
    VK_COMPONENT_TYPE_UINT32_NV = 9,
    VK_COMPONENT_TYPE_UINT64_NV = 10,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceDiagnosticsConfigFlagBitsNV
{
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 1,
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 2,
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineCreationFeedbackFlagBitsEXT
{
    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 1,
    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 2,
    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFullScreenExclusiveEXT
{
    VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
    VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
    VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
    VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceCounterScopeKHR
{
    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
    VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceCounterUnitKHR
{
    VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
    VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
    VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
    VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
    VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
    VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
    VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
    VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
    VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
    VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
    VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceCounterStorageKHR
{
    VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
    VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
    VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
    VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceCounterDescriptionFlagBitsKHR
{
    VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 1,
    VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 2,
}

type VkAcquireProfilingLockFlagBitsKHR = u32;

type VkShaderCorePropertiesFlagBitsAMD = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceConfigurationTypeINTEL
{
    VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryPoolSamplingModeINTEL
{
    VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceOverrideTypeINTEL
{
    VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
    VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceParameterTypeINTEL
{
    VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
    VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceValueTypeINTEL
{
    VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
    VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
    VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
    VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
    VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderFloatControlsIndependence
{
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineExecutableStatisticFormatKHR
{
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkLineRasterizationModeEXT
{
    VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0,
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1,
    VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2,
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3,
}

type VkShaderModuleCreateFlagBits = u32;

type VkPipelineCompilerControlFlagBitsAMD = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkToolPurposeFlagBitsEXT
{
    VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = 1,
    VK_TOOL_PURPOSE_PROFILING_BIT_EXT = 2,
    VK_TOOL_PURPOSE_TRACING_BIT_EXT = 4,
    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 8,
    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFragmentShadingRateCombinerOpKHR
{
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFragmentShadingRateNV
{
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
    VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
    VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
    VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
    VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
    VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFragmentShadingRateTypeNV
{
    VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
    VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
}

#[repr(i64)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccessFlagBits2KHR
{
    VK_ACCESS_2_NONE_KHR = 0,
    VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 1,
    VK_ACCESS_2_INDEX_READ_BIT_KHR = 2,
    VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 4,
    VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 8,
    VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 16,
    VK_ACCESS_2_SHADER_READ_BIT_KHR = 32,
    VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 64,
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 128,
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 256,
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 512,
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 1024,
    VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 2048,
    VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 4096,
    VK_ACCESS_2_HOST_READ_BIT_KHR = 8192,
    VK_ACCESS_2_HOST_WRITE_BIT_KHR = 16384,
    VK_ACCESS_2_MEMORY_READ_BIT_KHR = 32768,
    VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 65536,
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 4294967296,
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 8589934592,
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 17179869184,
}

#[repr(i64)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineStageFlagBits2KHR
{
    VK_PIPELINE_STAGE_2_NONE_KHR = 0,
    VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 1,
    VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 2,
    VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 4,
    VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 8,
    VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 16,
    VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 32,
    VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 64,
    VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 128,
    VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 256,
    VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 512,
    VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 1024,
    VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 2048,
    VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 4096,
    VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 8192,
    VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 16384,
    VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 32768,
    VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 65536,
    VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 4294967296,
    VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 8589934592,
    VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 17179869184,
    VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 34359738368,
    VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 68719476736,
    VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 137438953472,
    VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 274877906944,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSubmitFlagBitsKHR
{
    VK_SUBMIT_PROTECTED_BIT_KHR = 1,
}

type VkEventCreateFlagBits = u32;

type VkPipelineLayoutCreateFlagBits = u32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkProvokingVertexModeEXT
{
    VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
    VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureMotionInstanceTypeNV
{
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoCodecOperationFlagBitsKHR
{
    VK_VIDEO_CODEC_OPERATION_INVALID_BIT_KHR = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoChromaSubsamplingFlagBitsKHR
{
    VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_BIT_KHR = 0,
    VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 1,
    VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 2,
    VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 4,
    VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoComponentBitDepthFlagBitsKHR
{
    VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
    VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 1,
    VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 4,
    VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoCapabilityFlagBitsKHR
{
    VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 1,
    VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoSessionCreateFlagBitsKHR
{
    VK_VIDEO_SESSION_CREATE_DEFAULT_KHR = 0,
    VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoCodingQualityPresetFlagBitsKHR
{
    VK_VIDEO_CODING_QUALITY_PRESET_NORMAL_BIT_KHR = 1,
    VK_VIDEO_CODING_QUALITY_PRESET_POWER_BIT_KHR = 2,
    VK_VIDEO_CODING_QUALITY_PRESET_QUALITY_BIT_KHR = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoDecodeH264PictureLayoutFlagBitsEXT
{
    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT = 0,
    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_EXT = 1,
    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_EXT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoCodingControlFlagBitsKHR
{
    VK_VIDEO_CODING_CONTROL_DEFAULT_KHR = 0,
    VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryResultStatusKHR
{
    VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
    VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
    VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoDecodeFlagBitsKHR
{
    VK_VIDEO_DECODE_DEFAULT_KHR = 0,
    VK_VIDEO_DECODE_RESERVED_0_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeFlagBitsKHR
{
    VK_VIDEO_ENCODE_DEFAULT_KHR = 0,
    VK_VIDEO_ENCODE_RESERVED_0_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeRateControlFlagBitsKHR
{
    VK_VIDEO_ENCODE_RATE_CONTROL_DEFAULT_KHR = 0,
    VK_VIDEO_ENCODE_RATE_CONTROL_RESET_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeRateControlModeFlagBitsKHR
{
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR = 0,
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 1,
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeH264CapabilityFlagBitsEXT
{
    VK_VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT = 1,
    VK_VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT = 2,
    VK_VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BI_PRED_IMPLICIT_BIT_EXT = 4,
    VK_VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT = 8,
    VK_VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT = 16,
    VK_VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT = 32,
    VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_DISABLED_BIT_EXT = 64,
    VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_ENABLED_BIT_EXT = 128,
    VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = 256,
    VK_VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICE_PER_FRAME_BIT_EXT = 512,
    VK_VIDEO_ENCODE_H264_CAPABILITY_EVENLY_DISTRIBUTED_SLICE_SIZE_BIT_EXT = 1024,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeH264InputModeFlagBitsEXT
{
    VK_VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT = 1,
    VK_VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT = 2,
    VK_VIDEO_ENCODE_H264_INPUT_MODE_NON_VCL_BIT_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeH264OutputModeFlagBitsEXT
{
    VK_VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT = 1,
    VK_VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT = 2,
    VK_VIDEO_ENCODE_H264_OUTPUT_MODE_NON_VCL_BIT_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeH264CreateFlagBitsEXT
{
    VK_VIDEO_ENCODE_H264_CREATE_DEFAULT_EXT = 0,
    VK_VIDEO_ENCODE_H264_CREATE_RESERVED_0_BIT_EXT = 1,
}

type VkQueryPoolCreateFlagBits = u32;

type VkDescriptorUpdateTemplateCreateFlagBits = u32;

type VkPipelineDepthStencilStateCreateFlagBits = u32;

type VkPipelineDynamicStateCreateFlagBits = u32;

type VkBufferViewCreateFlagBits = u32;

type VkPipelineViewportStateCreateFlagBits = u32;

type VkPipelineRasterizationStateCreateFlagBits = u32;

type VkPipelineColorBlendStateCreateFlagBits = u32;

type VkPipelineVertexInputStateCreateFlagBits = u32;

type VkPipelineTessellationStateCreateFlagBits = u32;

type VkPipelineInputAssemblyStateCreateFlagBits = u32;

type VkPipelineMultisampleStateCreateFlagBits = u32;

type VkInstanceCreateFlagBits = u32;

type VkDeviceCreateFlagBits = u32;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBaseOutStructure
{
    pub sType: VkStructureType,
    pub pNext: * mut VkBaseOutStructure,
}
impl VkBaseOutStructure
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBaseInStructure
{
    pub sType: VkStructureType,
    pub pNext: * const VkBaseInStructure,
}
impl VkBaseInStructure
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkOffset2D
{
    pub x: i32,
    pub y: i32,
}
impl VkOffset2D
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkOffset3D
{
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl VkOffset3D
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExtent2D
{
    pub width: u32,
    pub height: u32,
}
impl VkExtent2D
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExtent3D
{
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl VkExtent3D
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkViewport
{
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub minDepth: f32,
    pub maxDepth: f32,
}
impl VkViewport
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRect2D
{
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
}
impl VkRect2D
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearRect
{
    pub rect: VkRect2D,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
impl VkClearRect
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkComponentMapping
{
    pub r: VkComponentSwizzle,
    pub g: VkComponentSwizzle,
    pub b: VkComponentSwizzle,
    pub a: VkComponentSwizzle,
}
impl VkComponentMapping
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProperties
{
    pub apiVersion: u32,
    pub driverVersion: u32,
    pub vendorID: u32,
    pub deviceID: u32,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [c_uchar; VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    pub pipelineCacheUUID: [u8; VK_UUID_SIZE],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
impl VkPhysicalDeviceProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExtensionProperties
{
    pub extensionName: [c_uchar; VK_MAX_EXTENSION_NAME_SIZE],
    pub specVersion: u32,
}
impl VkExtensionProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkLayerProperties
{
    pub layerName: [c_uchar; VK_MAX_EXTENSION_NAME_SIZE],
    pub specVersion: u32,
    pub implementationVersion: u32,
    pub description: [c_uchar; VK_MAX_DESCRIPTION_SIZE],
}
impl VkLayerProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkApplicationInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub pApplicationName: * const c_uchar,
    pub applicationVersion: u32,
    pub pEngineName: * const c_uchar,
    pub engineVersion: u32,
    pub apiVersion: u32,
}
impl VkApplicationInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceQueueCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkDeviceQueueCreateFlagBits,
    pub queueFamilyIndex: u32,
    pub queueCount: u32,
    pub pQueuePriorities: * const f32,
}
impl VkDeviceQueueCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkDeviceCreateFlagBits,
    pub queueCreateInfoCount: u32,
    pub pQueueCreateInfos: * const VkDeviceQueueCreateInfo,
    pub enabledLayerCount: u32,
    pub ppEnabledLayerNames: * const * const c_uchar,
    pub enabledExtensionCount: u32,
    pub ppEnabledExtensionNames: * const * const c_uchar,
    pub pEnabledFeatures: * const VkPhysicalDeviceFeatures,
}
impl VkDeviceCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInstanceCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkInstanceCreateFlagBits,
    pub pApplicationInfo: * const VkApplicationInfo,
    pub enabledLayerCount: u32,
    pub ppEnabledLayerNames: * const * const c_uchar,
    pub enabledExtensionCount: u32,
    pub ppEnabledExtensionNames: * const * const c_uchar,
}
impl VkInstanceCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueueFamilyProperties
{
    pub queueFlags: VkQueueFlagBits,
    pub queueCount: u32,
    pub timestampValidBits: u32,
    pub minImageTransferGranularity: VkExtent3D,
}
impl VkQueueFamilyProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties
{
    pub memoryTypeCount: u32,
    pub memoryTypes: [VkMemoryType; VK_MAX_MEMORY_TYPES],
    pub memoryHeapCount: u32,
    pub memoryHeaps: [VkMemoryHeap; VK_MAX_MEMORY_HEAPS],
}
impl VkPhysicalDeviceMemoryProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryAllocateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: u32,
}
impl VkMemoryAllocateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryRequirements
{
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: u32,
}
impl VkMemoryRequirements
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageFormatProperties
{
    pub aspectMask: VkImageAspectFlagBits,
    pub imageGranularity: VkExtent3D,
    pub flags: VkSparseImageFormatFlagBits,
}
impl VkSparseImageFormatProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryRequirements
{
    pub formatProperties: VkSparseImageFormatProperties,
    pub imageMipTailFirstLod: u32,
    pub imageMipTailSize: VkDeviceSize,
    pub imageMipTailOffset: VkDeviceSize,
    pub imageMipTailStride: VkDeviceSize,
}
impl VkSparseImageMemoryRequirements
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryType
{
    pub propertyFlags: VkMemoryPropertyFlagBits,
    pub heapIndex: u32,
}
impl VkMemoryType
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryHeap
{
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlagBits,
}
impl VkMemoryHeap
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMappedMemoryRange
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
impl VkMappedMemoryRange
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFormatProperties
{
    pub linearTilingFeatures: VkFormatFeatureFlagBits,
    pub optimalTilingFeatures: VkFormatFeatureFlagBits,
    pub bufferFeatures: VkFormatFeatureFlagBits,
}
impl VkFormatProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageFormatProperties
{
    pub maxExtent: VkExtent3D,
    pub maxMipLevels: u32,
    pub maxArrayLayers: u32,
    pub sampleCounts: VkSampleCountFlagBits,
    pub maxResourceSize: VkDeviceSize,
}
impl VkImageFormatProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorBufferInfo
{
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
impl VkDescriptorBufferInfo
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorImageInfo
{
    pub sampler: VkSampler,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
}
impl VkDescriptorImageInfo
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkWriteDescriptorSet
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
    pub descriptorType: VkDescriptorType,
    pub pImageInfo: * const VkDescriptorImageInfo,
    pub pBufferInfo: * const VkDescriptorBufferInfo,
    pub pTexelBufferView: * const VkBufferView,
}
impl VkWriteDescriptorSet
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyDescriptorSet
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub srcSet: VkDescriptorSet,
    pub srcBinding: u32,
    pub srcArrayElement: u32,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
}
impl VkCopyDescriptorSet
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkBufferCreateFlagBits,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlagBits,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: * const u32,
}
impl VkBufferCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferViewCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkBufferViewCreateFlagBits,
    pub buffer: VkBuffer,
    pub format: VkFormat,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
impl VkBufferViewCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSubresource
{
    pub aspectMask: VkImageAspectFlagBits,
    pub mipLevel: u32,
    pub arrayLayer: u32,
}
impl VkImageSubresource
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSubresourceLayers
{
    pub aspectMask: VkImageAspectFlagBits,
    pub mipLevel: u32,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
impl VkImageSubresourceLayers
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSubresourceRange
{
    pub aspectMask: VkImageAspectFlagBits,
    pub baseMipLevel: u32,
    pub levelCount: u32,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
impl VkImageSubresourceRange
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryBarrier
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub srcAccessMask: VkAccessFlagBits,
    pub dstAccessMask: VkAccessFlagBits,
}
impl VkMemoryBarrier
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_BARRIER;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferMemoryBarrier
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub srcAccessMask: VkAccessFlagBits,
    pub dstAccessMask: VkAccessFlagBits,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
impl VkBufferMemoryBarrier
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageMemoryBarrier
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub srcAccessMask: VkAccessFlagBits,
    pub dstAccessMask: VkAccessFlagBits,
    pub oldLayout: VkImageLayout,
    pub newLayout: VkImageLayout,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
}
impl VkImageMemoryBarrier
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkImageCreateFlagBits,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: u32,
    pub arrayLayers: u32,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlagBits,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: * const u32,
    pub initialLayout: VkImageLayout,
}
impl VkImageCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubresourceLayout
{
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub rowPitch: VkDeviceSize,
    pub arrayPitch: VkDeviceSize,
    pub depthPitch: VkDeviceSize,
}
impl VkSubresourceLayout
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageViewCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkImageViewCreateFlagBits,
    pub image: VkImage,
    pub viewType: VkImageViewType,
    pub format: VkFormat,
    pub components: VkComponentMapping,
    pub subresourceRange: VkImageSubresourceRange,
}
impl VkImageViewCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferCopy
{
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}
impl VkBufferCopy
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseMemoryBind
{
    pub resourceOffset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlagBits,
}
impl VkSparseMemoryBind
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryBind
{
    pub subresource: VkImageSubresource,
    pub offset: VkOffset3D,
    pub extent: VkExtent3D,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlagBits,
}
impl VkSparseImageMemoryBind
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseBufferMemoryBindInfo
{
    pub buffer: VkBuffer,
    pub bindCount: u32,
    pub pBinds: * const VkSparseMemoryBind,
}
impl VkSparseBufferMemoryBindInfo
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageOpaqueMemoryBindInfo
{
    pub image: VkImage,
    pub bindCount: u32,
    pub pBinds: * const VkSparseMemoryBind,
}
impl VkSparseImageOpaqueMemoryBindInfo
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryBindInfo
{
    pub image: VkImage,
    pub bindCount: u32,
    pub pBinds: * const VkSparseImageMemoryBind,
}
impl VkSparseImageMemoryBindInfo
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindSparseInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: * const VkSemaphore,
    pub bufferBindCount: u32,
    pub pBufferBinds: * const VkSparseBufferMemoryBindInfo,
    pub imageOpaqueBindCount: u32,
    pub pImageOpaqueBinds: * const VkSparseImageOpaqueMemoryBindInfo,
    pub imageBindCount: u32,
    pub pImageBinds: * const VkSparseImageMemoryBindInfo,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphores: * const VkSemaphore,
}
impl VkBindSparseInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageCopy
{
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
impl VkImageCopy
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageBlit
{
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffsets: [VkOffset3D; 2],
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffsets: [VkOffset3D; 2],
}
impl VkImageBlit
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferImageCopy
{
    pub bufferOffset: VkDeviceSize,
    pub bufferRowLength: u32,
    pub bufferImageHeight: u32,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}
impl VkBufferImageCopy
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageResolve
{
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
impl VkImageResolve
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkShaderModuleCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkShaderModuleCreateFlagBits,
    pub codeSize: usize,
    pub pCode: * const u32,
}
impl VkShaderModuleCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutBinding
{
    pub binding: u32,
    pub descriptorType: VkDescriptorType,
    pub descriptorCount: u32,
    pub stageFlags: VkShaderStageFlagBits,
    pub pImmutableSamplers: * const VkSampler,
}
impl VkDescriptorSetLayoutBinding
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkDescriptorSetLayoutCreateFlagBits,
    pub bindingCount: u32,
    pub pBindings: * const VkDescriptorSetLayoutBinding,
}
impl VkDescriptorSetLayoutCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorPoolSize
{
    pub name_type: VkDescriptorType,
    pub descriptorCount: u32,
}
impl VkDescriptorPoolSize
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorPoolCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkDescriptorPoolCreateFlagBits,
    pub maxSets: u32,
    pub poolSizeCount: u32,
    pub pPoolSizes: * const VkDescriptorPoolSize,
}
impl VkDescriptorPoolCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetAllocateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub descriptorPool: VkDescriptorPool,
    pub descriptorSetCount: u32,
    pub pSetLayouts: * const VkDescriptorSetLayout,
}
impl VkDescriptorSetAllocateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSpecializationMapEntry
{
    pub constantID: u32,
    pub offset: u32,
    pub size: usize,
}
impl VkSpecializationMapEntry
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSpecializationInfo
{
    pub mapEntryCount: u32,
    pub pMapEntries: * const VkSpecializationMapEntry,
    pub dataSize: usize,
    pub pData: * const c_void,
}
impl VkSpecializationInfo
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineShaderStageCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineShaderStageCreateFlagBits,
    pub stage: VkShaderStageFlagBits,
    pub module: VkShaderModule,
    pub pName: * const c_uchar,
    pub pSpecializationInfo: * const VkSpecializationInfo,
}
impl VkPipelineShaderStageCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkComputePipelineCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineCreateFlagBits,
    pub stage: VkPipelineShaderStageCreateInfo,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
impl VkComputePipelineCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVertexInputBindingDescription
{
    pub binding: u32,
    pub stride: u32,
    pub inputRate: VkVertexInputRate,
}
impl VkVertexInputBindingDescription
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVertexInputAttributeDescription
{
    pub location: u32,
    pub binding: u32,
    pub format: VkFormat,
    pub offset: u32,
}
impl VkVertexInputAttributeDescription
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineVertexInputStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineVertexInputStateCreateFlagBits,
    pub vertexBindingDescriptionCount: u32,
    pub pVertexBindingDescriptions: * const VkVertexInputBindingDescription,
    pub vertexAttributeDescriptionCount: u32,
    pub pVertexAttributeDescriptions: * const VkVertexInputAttributeDescription,
}
impl VkPipelineVertexInputStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineInputAssemblyStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineInputAssemblyStateCreateFlagBits,
    pub topology: VkPrimitiveTopology,
    pub primitiveRestartEnable: VkBool32,
}
impl VkPipelineInputAssemblyStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineTessellationStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineTessellationStateCreateFlagBits,
    pub patchControlPoints: u32,
}
impl VkPipelineTessellationStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineViewportStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineViewportStateCreateFlagBits,
    pub viewportCount: u32,
    pub pViewports: * const VkViewport,
    pub scissorCount: u32,
    pub pScissors: * const VkRect2D,
}
impl VkPipelineViewportStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineRasterizationStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineRasterizationStateCreateFlagBits,
    pub depthClampEnable: VkBool32,
    pub rasterizerDiscardEnable: VkBool32,
    pub polygonMode: VkPolygonMode,
    pub cullMode: VkCullModeFlagBits,
    pub frontFace: VkFrontFace,
    pub depthBiasEnable: VkBool32,
    pub depthBiasConstantFactor: f32,
    pub depthBiasClamp: f32,
    pub depthBiasSlopeFactor: f32,
    pub lineWidth: f32,
}
impl VkPipelineRasterizationStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineMultisampleStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineMultisampleStateCreateFlagBits,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub sampleShadingEnable: VkBool32,
    pub minSampleShading: f32,
    pub pSampleMask: * const VkSampleMask,
    pub alphaToCoverageEnable: VkBool32,
    pub alphaToOneEnable: VkBool32,
}
impl VkPipelineMultisampleStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineColorBlendAttachmentState
{
    pub blendEnable: VkBool32,
    pub srcColorBlendFactor: VkBlendFactor,
    pub dstColorBlendFactor: VkBlendFactor,
    pub colorBlendOp: VkBlendOp,
    pub srcAlphaBlendFactor: VkBlendFactor,
    pub dstAlphaBlendFactor: VkBlendFactor,
    pub alphaBlendOp: VkBlendOp,
    pub colorWriteMask: VkColorComponentFlagBits,
}
impl VkPipelineColorBlendAttachmentState
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineColorBlendStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineColorBlendStateCreateFlagBits,
    pub logicOpEnable: VkBool32,
    pub logicOp: VkLogicOp,
    pub attachmentCount: u32,
    pub pAttachments: * const VkPipelineColorBlendAttachmentState,
    pub blendConstants: [f32; 4],
}
impl VkPipelineColorBlendStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineDynamicStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineDynamicStateCreateFlagBits,
    pub dynamicStateCount: u32,
    pub pDynamicStates: * const VkDynamicState,
}
impl VkPipelineDynamicStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkStencilOpState
{
    pub failOp: VkStencilOp,
    pub passOp: VkStencilOp,
    pub depthFailOp: VkStencilOp,
    pub compareOp: VkCompareOp,
    pub compareMask: u32,
    pub writeMask: u32,
    pub reference: u32,
}
impl VkStencilOpState
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineDepthStencilStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineDepthStencilStateCreateFlagBits,
    pub depthTestEnable: VkBool32,
    pub depthWriteEnable: VkBool32,
    pub depthCompareOp: VkCompareOp,
    pub depthBoundsTestEnable: VkBool32,
    pub stencilTestEnable: VkBool32,
    pub front: VkStencilOpState,
    pub back: VkStencilOpState,
    pub minDepthBounds: f32,
    pub maxDepthBounds: f32,
}
impl VkPipelineDepthStencilStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGraphicsPipelineCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineCreateFlagBits,
    pub stageCount: u32,
    pub pStages: * const VkPipelineShaderStageCreateInfo,
    pub pVertexInputState: * const VkPipelineVertexInputStateCreateInfo,
    pub pInputAssemblyState: * const VkPipelineInputAssemblyStateCreateInfo,
    pub pTessellationState: * const VkPipelineTessellationStateCreateInfo,
    pub pViewportState: * const VkPipelineViewportStateCreateInfo,
    pub pRasterizationState: * const VkPipelineRasterizationStateCreateInfo,
    pub pMultisampleState: * const VkPipelineMultisampleStateCreateInfo,
    pub pDepthStencilState: * const VkPipelineDepthStencilStateCreateInfo,
    pub pColorBlendState: * const VkPipelineColorBlendStateCreateInfo,
    pub pDynamicState: * const VkPipelineDynamicStateCreateInfo,
    pub layout: VkPipelineLayout,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
impl VkGraphicsPipelineCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineCacheCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineCacheCreateFlagBits,
    pub initialDataSize: usize,
    pub pInitialData: * const c_void,
}
impl VkPipelineCacheCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineCacheHeaderVersionOne
{
    pub headerSize: u32,
    pub headerVersion: VkPipelineCacheHeaderVersion,
    pub vendorID: u32,
    pub deviceID: u32,
    pub pipelineCacheUUID: [u8; VK_UUID_SIZE],
}
impl VkPipelineCacheHeaderVersionOne
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPushConstantRange
{
    pub stageFlags: VkShaderStageFlagBits,
    pub offset: u32,
    pub size: u32,
}
impl VkPushConstantRange
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineLayoutCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkPipelineLayoutCreateFlagBits,
    pub setLayoutCount: u32,
    pub pSetLayouts: * const VkDescriptorSetLayout,
    pub pushConstantRangeCount: u32,
    pub pPushConstantRanges: * const VkPushConstantRange,
}
impl VkPipelineLayoutCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkSamplerCreateFlagBits,
    pub magFilter: VkFilter,
    pub minFilter: VkFilter,
    pub mipmapMode: VkSamplerMipmapMode,
    pub addressModeU: VkSamplerAddressMode,
    pub addressModeV: VkSamplerAddressMode,
    pub addressModeW: VkSamplerAddressMode,
    pub mipLodBias: f32,
    pub anisotropyEnable: VkBool32,
    pub maxAnisotropy: f32,
    pub compareEnable: VkBool32,
    pub compareOp: VkCompareOp,
    pub minLod: f32,
    pub maxLod: f32,
    pub borderColor: VkBorderColor,
    pub unnormalizedCoordinates: VkBool32,
}
impl VkSamplerCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandPoolCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkCommandPoolCreateFlagBits,
    pub queueFamilyIndex: u32,
}
impl VkCommandPoolCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferAllocateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub commandPool: VkCommandPool,
    pub level: VkCommandBufferLevel,
    pub commandBufferCount: u32,
}
impl VkCommandBufferAllocateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferInheritanceInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
    pub framebuffer: VkFramebuffer,
    pub occlusionQueryEnable: VkBool32,
    pub queryFlags: VkQueryControlFlagBits,
    pub pipelineStatistics: VkQueryPipelineStatisticFlagBits,
}
impl VkCommandBufferInheritanceInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferBeginInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkCommandBufferUsageFlagBits,
    pub pInheritanceInfo: * const VkCommandBufferInheritanceInfo,
}
impl VkCommandBufferBeginInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassBeginInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub renderPass: VkRenderPass,
    pub framebuffer: VkFramebuffer,
    pub renderArea: VkRect2D,
    pub clearValueCount: u32,
    pub pClearValues: * const VkClearValue,
}
impl VkRenderPassBeginInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearDepthStencilValue
{
    pub depth: f32,
    pub stencil: u32,
}
impl VkClearDepthStencilValue
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearAttachment
{
    pub aspectMask: VkImageAspectFlagBits,
    pub colorAttachment: u32,
    pub clearValue: VkClearValue,
}
impl VkClearAttachment
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentDescription
{
    pub flags: VkAttachmentDescriptionFlagBits,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}
impl VkAttachmentDescription
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentReference
{
    pub attachment: u32,
    pub layout: VkImageLayout,
}
impl VkAttachmentReference
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescription
{
    pub flags: VkSubpassDescriptionFlagBits,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub inputAttachmentCount: u32,
    pub pInputAttachments: * const VkAttachmentReference,
    pub colorAttachmentCount: u32,
    pub pColorAttachments: * const VkAttachmentReference,
    pub pResolveAttachments: * const VkAttachmentReference,
    pub pDepthStencilAttachment: * const VkAttachmentReference,
    pub preserveAttachmentCount: u32,
    pub pPreserveAttachments: * const u32,
}
impl VkSubpassDescription
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDependency
{
    pub srcSubpass: u32,
    pub dstSubpass: u32,
    pub srcStageMask: VkPipelineStageFlagBits,
    pub dstStageMask: VkPipelineStageFlagBits,
    pub srcAccessMask: VkAccessFlagBits,
    pub dstAccessMask: VkAccessFlagBits,
    pub dependencyFlags: VkDependencyFlagBits,
}
impl VkSubpassDependency
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkRenderPassCreateFlagBits,
    pub attachmentCount: u32,
    pub pAttachments: * const VkAttachmentDescription,
    pub subpassCount: u32,
    pub pSubpasses: * const VkSubpassDescription,
    pub dependencyCount: u32,
    pub pDependencies: * const VkSubpassDependency,
}
impl VkRenderPassCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkEventCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkEventCreateFlagBits,
}
impl VkEventCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFenceCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkFenceCreateFlagBits,
}
impl VkFenceCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceFeatures
{
    pub robustBufferAccess: VkBool32,
    pub fullDrawIndexUint32: VkBool32,
    pub imageCubeArray: VkBool32,
    pub independentBlend: VkBool32,
    pub geometryShader: VkBool32,
    pub tessellationShader: VkBool32,
    pub sampleRateShading: VkBool32,
    pub dualSrcBlend: VkBool32,
    pub logicOp: VkBool32,
    pub multiDrawIndirect: VkBool32,
    pub drawIndirectFirstInstance: VkBool32,
    pub depthClamp: VkBool32,
    pub depthBiasClamp: VkBool32,
    pub fillModeNonSolid: VkBool32,
    pub depthBounds: VkBool32,
    pub wideLines: VkBool32,
    pub largePoints: VkBool32,
    pub alphaToOne: VkBool32,
    pub multiViewport: VkBool32,
    pub samplerAnisotropy: VkBool32,
    pub textureCompressionETC2: VkBool32,
    pub textureCompressionASTC_LDR: VkBool32,
    pub textureCompressionBC: VkBool32,
    pub occlusionQueryPrecise: VkBool32,
    pub pipelineStatisticsQuery: VkBool32,
    pub vertexPipelineStoresAndAtomics: VkBool32,
    pub fragmentStoresAndAtomics: VkBool32,
    pub shaderTessellationAndGeometryPointSize: VkBool32,
    pub shaderImageGatherExtended: VkBool32,
    pub shaderStorageImageExtendedFormats: VkBool32,
    pub shaderStorageImageMultisample: VkBool32,
    pub shaderStorageImageReadWithoutFormat: VkBool32,
    pub shaderStorageImageWriteWithoutFormat: VkBool32,
    pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
    pub shaderSampledImageArrayDynamicIndexing: VkBool32,
    pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageImageArrayDynamicIndexing: VkBool32,
    pub shaderClipDistance: VkBool32,
    pub shaderCullDistance: VkBool32,
    pub shaderFloat64: VkBool32,
    pub shaderInt64: VkBool32,
    pub shaderInt16: VkBool32,
    pub shaderResourceResidency: VkBool32,
    pub shaderResourceMinLod: VkBool32,
    pub sparseBinding: VkBool32,
    pub sparseResidencyBuffer: VkBool32,
    pub sparseResidencyImage2D: VkBool32,
    pub sparseResidencyImage3D: VkBool32,
    pub sparseResidency2Samples: VkBool32,
    pub sparseResidency4Samples: VkBool32,
    pub sparseResidency8Samples: VkBool32,
    pub sparseResidency16Samples: VkBool32,
    pub sparseResidencyAliased: VkBool32,
    pub variableMultisampleRate: VkBool32,
    pub inheritedQueries: VkBool32,
}
impl VkPhysicalDeviceFeatures
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSparseProperties
{
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}
impl VkPhysicalDeviceSparseProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceLimits
{
    pub maxImageDimension1D: u32,
    pub maxImageDimension2D: u32,
    pub maxImageDimension3D: u32,
    pub maxImageDimensionCube: u32,
    pub maxImageArrayLayers: u32,
    pub maxTexelBufferElements: u32,
    pub maxUniformBufferRange: u32,
    pub maxStorageBufferRange: u32,
    pub maxPushConstantsSize: u32,
    pub maxMemoryAllocationCount: u32,
    pub maxSamplerAllocationCount: u32,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: u32,
    pub maxPerStageDescriptorSamplers: u32,
    pub maxPerStageDescriptorUniformBuffers: u32,
    pub maxPerStageDescriptorStorageBuffers: u32,
    pub maxPerStageDescriptorSampledImages: u32,
    pub maxPerStageDescriptorStorageImages: u32,
    pub maxPerStageDescriptorInputAttachments: u32,
    pub maxPerStageResources: u32,
    pub maxDescriptorSetSamplers: u32,
    pub maxDescriptorSetUniformBuffers: u32,
    pub maxDescriptorSetUniformBuffersDynamic: u32,
    pub maxDescriptorSetStorageBuffers: u32,
    pub maxDescriptorSetStorageBuffersDynamic: u32,
    pub maxDescriptorSetSampledImages: u32,
    pub maxDescriptorSetStorageImages: u32,
    pub maxDescriptorSetInputAttachments: u32,
    pub maxVertexInputAttributes: u32,
    pub maxVertexInputBindings: u32,
    pub maxVertexInputAttributeOffset: u32,
    pub maxVertexInputBindingStride: u32,
    pub maxVertexOutputComponents: u32,
    pub maxTessellationGenerationLevel: u32,
    pub maxTessellationPatchSize: u32,
    pub maxTessellationControlPerVertexInputComponents: u32,
    pub maxTessellationControlPerVertexOutputComponents: u32,
    pub maxTessellationControlPerPatchOutputComponents: u32,
    pub maxTessellationControlTotalOutputComponents: u32,
    pub maxTessellationEvaluationInputComponents: u32,
    pub maxTessellationEvaluationOutputComponents: u32,
    pub maxGeometryShaderInvocations: u32,
    pub maxGeometryInputComponents: u32,
    pub maxGeometryOutputComponents: u32,
    pub maxGeometryOutputVertices: u32,
    pub maxGeometryTotalOutputComponents: u32,
    pub maxFragmentInputComponents: u32,
    pub maxFragmentOutputAttachments: u32,
    pub maxFragmentDualSrcAttachments: u32,
    pub maxFragmentCombinedOutputResources: u32,
    pub maxComputeSharedMemorySize: u32,
    pub maxComputeWorkGroupCount: [u32; 3],
    pub maxComputeWorkGroupInvocations: u32,
    pub maxComputeWorkGroupSize: [u32; 3],
    pub subPixelPrecisionBits: u32,
    pub subTexelPrecisionBits: u32,
    pub mipmapPrecisionBits: u32,
    pub maxDrawIndexedIndexValue: u32,
    pub maxDrawIndirectCount: u32,
    pub maxSamplerLodBias: f32,
    pub maxSamplerAnisotropy: f32,
    pub maxViewports: u32,
    pub maxViewportDimensions: [u32; 2],
    pub viewportBoundsRange: [f32; 2],
    pub viewportSubPixelBits: u32,
    pub minMemoryMapAlignment: usize,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: i32,
    pub maxTexelOffset: u32,
    pub minTexelGatherOffset: i32,
    pub maxTexelGatherOffset: u32,
    pub minInterpolationOffset: f32,
    pub maxInterpolationOffset: f32,
    pub subPixelInterpolationOffsetBits: u32,
    pub maxFramebufferWidth: u32,
    pub maxFramebufferHeight: u32,
    pub maxFramebufferLayers: u32,
    pub framebufferColorSampleCounts: VkSampleCountFlagBits,
    pub framebufferDepthSampleCounts: VkSampleCountFlagBits,
    pub framebufferStencilSampleCounts: VkSampleCountFlagBits,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlagBits,
    pub maxColorAttachments: u32,
    pub sampledImageColorSampleCounts: VkSampleCountFlagBits,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlagBits,
    pub sampledImageDepthSampleCounts: VkSampleCountFlagBits,
    pub sampledImageStencilSampleCounts: VkSampleCountFlagBits,
    pub storageImageSampleCounts: VkSampleCountFlagBits,
    pub maxSampleMaskWords: u32,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: f32,
    pub maxClipDistances: u32,
    pub maxCullDistances: u32,
    pub maxCombinedClipAndCullDistances: u32,
    pub discreteQueuePriorities: u32,
    pub pointSizeRange: [f32; 2],
    pub lineWidthRange: [f32; 2],
    pub pointSizeGranularity: f32,
    pub lineWidthGranularity: f32,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}
impl VkPhysicalDeviceLimits
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkSemaphoreCreateFlagBits,
}
impl VkSemaphoreCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueryPoolCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkQueryPoolCreateFlagBits,
    pub queryType: VkQueryType,
    pub queryCount: u32,
    pub pipelineStatistics: VkQueryPipelineStatisticFlagBits,
}
impl VkQueryPoolCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkFramebufferCreateFlagBits,
    pub renderPass: VkRenderPass,
    pub attachmentCount: u32,
    pub pAttachments: * const VkImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
}
impl VkFramebufferCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDrawIndirectCommand
{
    pub vertexCount: u32,
    pub instanceCount: u32,
    pub firstVertex: u32,
    pub firstInstance: u32,
}
impl VkDrawIndirectCommand
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDrawIndexedIndirectCommand
{
    pub indexCount: u32,
    pub instanceCount: u32,
    pub firstIndex: u32,
    pub vertexOffset: i32,
    pub firstInstance: u32,
}
impl VkDrawIndexedIndirectCommand
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDispatchIndirectCommand
{
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
impl VkDispatchIndirectCommand
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubmitInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: * const VkSemaphore,
    pub pWaitDstStageMask: * const VkPipelineStageFlagBits,
    pub commandBufferCount: u32,
    pub pCommandBuffers: * const VkCommandBuffer,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphores: * const VkSemaphore,
}
impl VkSubmitInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceFeatures2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub features: VkPhysicalDeviceFeatures,
}
impl VkPhysicalDeviceFeatures2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProperties2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub properties: VkPhysicalDeviceProperties,
}
impl VkPhysicalDeviceProperties2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFormatProperties2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub formatProperties: VkFormatProperties,
}
impl VkFormatProperties2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageFormatProperties2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub imageFormatProperties: VkImageFormatProperties,
}
impl VkImageFormatProperties2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceImageFormatInfo2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub format: VkFormat,
    pub name_type: VkImageType,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlagBits,
    pub flags: VkImageCreateFlagBits,
}
impl VkPhysicalDeviceImageFormatInfo2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueueFamilyProperties2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub queueFamilyProperties: VkQueueFamilyProperties,
}
impl VkQueueFamilyProperties2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub memoryProperties: VkPhysicalDeviceMemoryProperties,
}
impl VkPhysicalDeviceMemoryProperties2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageFormatProperties2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub properties: VkSparseImageFormatProperties,
}
impl VkSparseImageFormatProperties2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub format: VkFormat,
    pub name_type: VkImageType,
    pub samples: VkSampleCountFlagBits,
    pub usage: VkImageUsageFlagBits,
    pub tiling: VkImageTiling,
}
impl VkPhysicalDeviceSparseImageFormatInfo2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkConformanceVersion
{
    pub major: u8,
    pub minor: u8,
    pub subminor: u8,
    pub patch: u8,
}
impl VkConformanceVersion
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDriverProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub driverID: VkDriverId,
    pub driverName: [c_uchar; VK_MAX_DRIVER_NAME_SIZE],
    pub driverInfo: [c_uchar; VK_MAX_DRIVER_INFO_SIZE],
    pub conformanceVersion: VkConformanceVersion,
}
impl VkPhysicalDeviceDriverProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVariablePointersFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub variablePointersStorageBuffer: VkBool32,
    pub variablePointers: VkBool32,
}
impl VkPhysicalDeviceVariablePointersFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVariablePointerFeatures
{
}
impl VkPhysicalDeviceVariablePointerFeatures
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalMemoryProperties
{
    pub externalMemoryFeatures: VkExternalMemoryFeatureFlagBits,
    pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagBits,
    pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlagBits,
}
impl VkExternalMemoryProperties
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalImageFormatInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl VkPhysicalDeviceExternalImageFormatInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalImageFormatProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub externalMemoryProperties: VkExternalMemoryProperties,
}
impl VkExternalImageFormatProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalBufferInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkBufferCreateFlagBits,
    pub usage: VkBufferUsageFlagBits,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl VkPhysicalDeviceExternalBufferInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalBufferProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub externalMemoryProperties: VkExternalMemoryProperties,
}
impl VkExternalBufferProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceIDProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub deviceUUID: [u8; VK_UUID_SIZE],
    pub driverUUID: [u8; VK_UUID_SIZE],
    pub deviceLUID: [u8; VK_LUID_SIZE],
    pub deviceNodeMask: u32,
    pub deviceLUIDValid: VkBool32,
}
impl VkPhysicalDeviceIDProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalMemoryImageCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagBits,
}
impl VkExternalMemoryImageCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalMemoryBufferCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagBits,
}
impl VkExternalMemoryBufferCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExportMemoryAllocateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagBits,
}
impl VkExportMemoryAllocateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalSemaphoreInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
impl VkPhysicalDeviceExternalSemaphoreInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalSemaphoreProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlagBits,
    pub compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlagBits,
    pub externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlagBits,
}
impl VkExternalSemaphoreProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExportSemaphoreCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub handleTypes: VkExternalSemaphoreHandleTypeFlagBits,
}
impl VkExportSemaphoreCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalFenceInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub handleType: VkExternalFenceHandleTypeFlagBits,
}
impl VkPhysicalDeviceExternalFenceInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalFenceProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlagBits,
    pub compatibleHandleTypes: VkExternalFenceHandleTypeFlagBits,
    pub externalFenceFeatures: VkExternalFenceFeatureFlagBits,
}
impl VkExternalFenceProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExportFenceCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub handleTypes: VkExternalFenceHandleTypeFlagBits,
}
impl VkExportFenceCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub multiview: VkBool32,
    pub multiviewGeometryShader: VkBool32,
    pub multiviewTessellationShader: VkBool32,
}
impl VkPhysicalDeviceMultiviewFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub maxMultiviewViewCount: u32,
    pub maxMultiviewInstanceIndex: u32,
}
impl VkPhysicalDeviceMultiviewProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassMultiviewCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub subpassCount: u32,
    pub pViewMasks: * const u32,
    pub dependencyCount: u32,
    pub pViewOffsets: * const i32,
    pub correlationMaskCount: u32,
    pub pCorrelationMasks: * const u32,
}
impl VkRenderPassMultiviewCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceGroupProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub physicalDeviceCount: u32,
    pub physicalDevices: [VkPhysicalDevice; VK_MAX_DEVICE_GROUP_SIZE],
    pub subsetAllocation: VkBool32,
}
impl VkPhysicalDeviceGroupProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryAllocateFlagsInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkMemoryAllocateFlagBits,
    pub deviceMask: u32,
}
impl VkMemoryAllocateFlagsInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindBufferMemoryInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub buffer: VkBuffer,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
impl VkBindBufferMemoryInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindBufferMemoryDeviceGroupInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: * const u32,
}
impl VkBindBufferMemoryDeviceGroupInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindImageMemoryInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub image: VkImage,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
impl VkBindImageMemoryInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindImageMemoryDeviceGroupInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: * const u32,
    pub splitInstanceBindRegionCount: u32,
    pub pSplitInstanceBindRegions: * const VkRect2D,
}
impl VkBindImageMemoryDeviceGroupInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupRenderPassBeginInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub deviceMask: u32,
    pub deviceRenderAreaCount: u32,
    pub pDeviceRenderAreas: * const VkRect2D,
}
impl VkDeviceGroupRenderPassBeginInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupCommandBufferBeginInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub deviceMask: u32,
}
impl VkDeviceGroupCommandBufferBeginInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupSubmitInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphoreDeviceIndices: * const u32,
    pub commandBufferCount: u32,
    pub pCommandBufferDeviceMasks: * const u32,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphoreDeviceIndices: * const u32,
}
impl VkDeviceGroupSubmitInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupBindSparseInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub resourceDeviceIndex: u32,
    pub memoryDeviceIndex: u32,
}
impl VkDeviceGroupBindSparseInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupDeviceCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub physicalDeviceCount: u32,
    pub pPhysicalDevices: * const VkPhysicalDevice,
}
impl VkDeviceGroupDeviceCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorUpdateTemplateEntry
{
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
    pub descriptorType: VkDescriptorType,
    pub offset: usize,
    pub stride: usize,
}
impl VkDescriptorUpdateTemplateEntry
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorUpdateTemplateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkDescriptorUpdateTemplateCreateFlagBits,
    pub descriptorUpdateEntryCount: u32,
    pub pDescriptorUpdateEntries: * const VkDescriptorUpdateTemplateEntry,
    pub templateType: VkDescriptorUpdateTemplateType,
    pub descriptorSetLayout: VkDescriptorSetLayout,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub pipelineLayout: VkPipelineLayout,
    pub set: u32,
}
impl VkDescriptorUpdateTemplateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInputAttachmentAspectReference
{
    pub subpass: u32,
    pub inputAttachmentIndex: u32,
    pub aspectMask: VkImageAspectFlagBits,
}
impl VkInputAttachmentAspectReference
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassInputAttachmentAspectCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub aspectReferenceCount: u32,
    pub pAspectReferences: * const VkInputAttachmentAspectReference,
}
impl VkRenderPassInputAttachmentAspectCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDevice16BitStorageFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub storageBuffer16BitAccess: VkBool32,
    pub uniformAndStorageBuffer16BitAccess: VkBool32,
    pub storagePushConstant16: VkBool32,
    pub storageInputOutput16: VkBool32,
}
impl VkPhysicalDevice16BitStorageFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSubgroupProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub subgroupSize: u32,
    pub supportedStages: VkShaderStageFlagBits,
    pub supportedOperations: VkSubgroupFeatureFlagBits,
    pub quadOperationsInAllStages: VkBool32,
}
impl VkPhysicalDeviceSubgroupProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub shaderSubgroupExtendedTypes: VkBool32,
}
impl VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferMemoryRequirementsInfo2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub buffer: VkBuffer,
}
impl VkBufferMemoryRequirementsInfo2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageMemoryRequirementsInfo2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub image: VkImage,
}
impl VkImageMemoryRequirementsInfo2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSparseMemoryRequirementsInfo2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub image: VkImage,
}
impl VkImageSparseMemoryRequirementsInfo2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryRequirements2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub memoryRequirements: VkMemoryRequirements,
}
impl VkMemoryRequirements2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryRequirements2
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub memoryRequirements: VkSparseImageMemoryRequirements,
}
impl VkSparseImageMemoryRequirements2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDevicePointClippingProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub pointClippingBehavior: VkPointClippingBehavior,
}
impl VkPhysicalDevicePointClippingProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryDedicatedRequirements
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub prefersDedicatedAllocation: VkBool32,
    pub requiresDedicatedAllocation: VkBool32,
}
impl VkMemoryDedicatedRequirements
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryDedicatedAllocateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub image: VkImage,
    pub buffer: VkBuffer,
}
impl VkMemoryDedicatedAllocateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageViewUsageCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub usage: VkImageUsageFlagBits,
}
impl VkImageViewUsageCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineTessellationDomainOriginStateCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub domainOrigin: VkTessellationDomainOrigin,
}
impl VkPipelineTessellationDomainOriginStateCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerYcbcrConversionInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub conversion: VkSamplerYcbcrConversion,
}
impl VkSamplerYcbcrConversionInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerYcbcrConversionCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub format: VkFormat,
    pub ycbcrModel: VkSamplerYcbcrModelConversion,
    pub ycbcrRange: VkSamplerYcbcrRange,
    pub components: VkComponentMapping,
    pub xChromaOffset: VkChromaLocation,
    pub yChromaOffset: VkChromaLocation,
    pub chromaFilter: VkFilter,
    pub forceExplicitReconstruction: VkBool32,
}
impl VkSamplerYcbcrConversionCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindImagePlaneMemoryInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub planeAspect: VkImageAspectFlagBits,
}
impl VkBindImagePlaneMemoryInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImagePlaneMemoryRequirementsInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub planeAspect: VkImageAspectFlagBits,
}
impl VkImagePlaneMemoryRequirementsInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSamplerYcbcrConversionFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub samplerYcbcrConversion: VkBool32,
}
impl VkPhysicalDeviceSamplerYcbcrConversionFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerYcbcrConversionImageFormatProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub combinedImageSamplerDescriptorCount: u32,
}
impl VkSamplerYcbcrConversionImageFormatProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkProtectedSubmitInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub protectedSubmit: VkBool32,
}
impl VkProtectedSubmitInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProtectedMemoryFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub protectedMemory: VkBool32,
}
impl VkPhysicalDeviceProtectedMemoryFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProtectedMemoryProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub protectedNoFault: VkBool32,
}
impl VkPhysicalDeviceProtectedMemoryProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceQueueInfo2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkDeviceQueueCreateFlagBits,
    pub queueFamilyIndex: u32,
    pub queueIndex: u32,
}
impl VkDeviceQueueInfo2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSamplerFilterMinmaxProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub filterMinmaxSingleComponentFormats: VkBool32,
    pub filterMinmaxImageComponentMapping: VkBool32,
}
impl VkPhysicalDeviceSamplerFilterMinmaxProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerReductionModeCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub reductionMode: VkSamplerReductionMode,
}
impl VkSamplerReductionModeCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageFormatListCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub viewFormatCount: u32,
    pub pViewFormats: * const VkFormat,
}
impl VkImageFormatListCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMaintenance3Properties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub maxPerSetDescriptors: u32,
    pub maxMemoryAllocationSize: VkDeviceSize,
}
impl VkPhysicalDeviceMaintenance3Properties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutSupport
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub supported: VkBool32,
}
impl VkDescriptorSetLayoutSupport
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderDrawParametersFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub shaderDrawParameters: VkBool32,
}
impl VkPhysicalDeviceShaderDrawParametersFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderDrawParameterFeatures
{
}
impl VkPhysicalDeviceShaderDrawParameterFeatures
{
    pub fn new() -> Self
    {
        let s: Self = unsafe { mem::zeroed() };

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderFloat16Int8Features
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub shaderFloat16: VkBool32,
    pub shaderInt8: VkBool32,
}
impl VkPhysicalDeviceShaderFloat16Int8Features
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceFloatControlsProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
    pub roundingModeIndependence: VkShaderFloatControlsIndependence,
    pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
    pub shaderDenormPreserveFloat16: VkBool32,
    pub shaderDenormPreserveFloat32: VkBool32,
    pub shaderDenormPreserveFloat64: VkBool32,
    pub shaderDenormFlushToZeroFloat16: VkBool32,
    pub shaderDenormFlushToZeroFloat32: VkBool32,
    pub shaderDenormFlushToZeroFloat64: VkBool32,
    pub shaderRoundingModeRTEFloat16: VkBool32,
    pub shaderRoundingModeRTEFloat32: VkBool32,
    pub shaderRoundingModeRTEFloat64: VkBool32,
    pub shaderRoundingModeRTZFloat16: VkBool32,
    pub shaderRoundingModeRTZFloat32: VkBool32,
    pub shaderRoundingModeRTZFloat64: VkBool32,
}
impl VkPhysicalDeviceFloatControlsProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceHostQueryResetFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub hostQueryReset: VkBool32,
}
impl VkPhysicalDeviceHostQueryResetFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorIndexingFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
    pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
    pub descriptorBindingPartiallyBound: VkBool32,
    pub descriptorBindingVariableDescriptorCount: VkBool32,
    pub runtimeDescriptorArray: VkBool32,
}
impl VkPhysicalDeviceDescriptorIndexingFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorIndexingProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub maxUpdateAfterBindDescriptorsInAllPools: u32,
    pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
    pub robustBufferAccessUpdateAfterBind: VkBool32,
    pub quadDivergentImplicitLod: VkBool32,
    pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    pub maxPerStageUpdateAfterBindResources: u32,
    pub maxDescriptorSetUpdateAfterBindSamplers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
    pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
    pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
}
impl VkPhysicalDeviceDescriptorIndexingProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutBindingFlagsCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub bindingCount: u32,
    pub pBindingFlags: * const VkDescriptorBindingFlagBits,
}
impl VkDescriptorSetLayoutBindingFlagsCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetVariableDescriptorCountAllocateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub descriptorSetCount: u32,
    pub pDescriptorCounts: * const u32,
}
impl VkDescriptorSetVariableDescriptorCountAllocateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetVariableDescriptorCountLayoutSupport
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub maxVariableDescriptorCount: u32,
}
impl VkDescriptorSetVariableDescriptorCountLayoutSupport
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentDescription2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkAttachmentDescriptionFlagBits,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}
impl VkAttachmentDescription2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentReference2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub attachment: u32,
    pub layout: VkImageLayout,
    pub aspectMask: VkImageAspectFlagBits,
}
impl VkAttachmentReference2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescription2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkSubpassDescriptionFlagBits,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub viewMask: u32,
    pub inputAttachmentCount: u32,
    pub pInputAttachments: * const VkAttachmentReference2,
    pub colorAttachmentCount: u32,
    pub pColorAttachments: * const VkAttachmentReference2,
    pub pResolveAttachments: * const VkAttachmentReference2,
    pub pDepthStencilAttachment: * const VkAttachmentReference2,
    pub preserveAttachmentCount: u32,
    pub pPreserveAttachments: * const u32,
}
impl VkSubpassDescription2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDependency2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub srcSubpass: u32,
    pub dstSubpass: u32,
    pub srcStageMask: VkPipelineStageFlagBits,
    pub dstStageMask: VkPipelineStageFlagBits,
    pub srcAccessMask: VkAccessFlagBits,
    pub dstAccessMask: VkAccessFlagBits,
    pub dependencyFlags: VkDependencyFlagBits,
    pub viewOffset: i32,
}
impl VkSubpassDependency2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassCreateInfo2
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkRenderPassCreateFlagBits,
    pub attachmentCount: u32,
    pub pAttachments: * const VkAttachmentDescription2,
    pub subpassCount: u32,
    pub pSubpasses: * const VkSubpassDescription2,
    pub dependencyCount: u32,
    pub pDependencies: * const VkSubpassDependency2,
    pub correlatedViewMaskCount: u32,
    pub pCorrelatedViewMasks: * const u32,
}
impl VkRenderPassCreateInfo2
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassBeginInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub contents: VkSubpassContents,
}
impl VkSubpassBeginInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassEndInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
}
impl VkSubpassEndInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_END_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceTimelineSemaphoreFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub timelineSemaphore: VkBool32,
}
impl VkPhysicalDeviceTimelineSemaphoreFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceTimelineSemaphoreProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub maxTimelineSemaphoreValueDifference: u64,
}
impl VkPhysicalDeviceTimelineSemaphoreProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreTypeCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub semaphoreType: VkSemaphoreType,
    pub initialValue: u64,
}
impl VkSemaphoreTypeCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkTimelineSemaphoreSubmitInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub waitSemaphoreValueCount: u32,
    pub pWaitSemaphoreValues: * const u64,
    pub signalSemaphoreValueCount: u32,
    pub pSignalSemaphoreValues: * const u64,
}
impl VkTimelineSemaphoreSubmitInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreWaitInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkSemaphoreWaitFlagBits,
    pub semaphoreCount: u32,
    pub pSemaphores: * const VkSemaphore,
    pub pValues: * const u64,
}
impl VkSemaphoreWaitInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreSignalInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub semaphore: VkSemaphore,
    pub value: u64,
}
impl VkSemaphoreSignalInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDevice8BitStorageFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub storageBuffer8BitAccess: VkBool32,
    pub uniformAndStorageBuffer8BitAccess: VkBool32,
    pub storagePushConstant8: VkBool32,
}
impl VkPhysicalDevice8BitStorageFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVulkanMemoryModelFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub vulkanMemoryModel: VkBool32,
    pub vulkanMemoryModelDeviceScope: VkBool32,
    pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
}
impl VkPhysicalDeviceVulkanMemoryModelFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderAtomicInt64Features
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub shaderBufferInt64Atomics: VkBool32,
    pub shaderSharedInt64Atomics: VkBool32,
}
impl VkPhysicalDeviceShaderAtomicInt64Features
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDepthStencilResolveProperties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub supportedDepthResolveModes: VkResolveModeFlagBits,
    pub supportedStencilResolveModes: VkResolveModeFlagBits,
    pub independentResolveNone: VkBool32,
    pub independentResolve: VkBool32,
}
impl VkPhysicalDeviceDepthStencilResolveProperties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescriptionDepthStencilResolve
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub depthResolveMode: VkResolveModeFlagBits,
    pub stencilResolveMode: VkResolveModeFlagBits,
    pub pDepthStencilResolveAttachment: * const VkAttachmentReference2,
}
impl VkSubpassDescriptionDepthStencilResolve
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageStencilUsageCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub stencilUsage: VkImageUsageFlagBits,
}
impl VkImageStencilUsageCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceScalarBlockLayoutFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub scalarBlockLayout: VkBool32,
}
impl VkPhysicalDeviceScalarBlockLayoutFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub uniformBufferStandardLayout: VkBool32,
}
impl VkPhysicalDeviceUniformBufferStandardLayoutFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub bufferDeviceAddress: VkBool32,
    pub bufferDeviceAddressCaptureReplay: VkBool32,
    pub bufferDeviceAddressMultiDevice: VkBool32,
}
impl VkPhysicalDeviceBufferDeviceAddressFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferDeviceAddressInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub buffer: VkBuffer,
}
impl VkBufferDeviceAddressInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferOpaqueCaptureAddressCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub opaqueCaptureAddress: u64,
}
impl VkBufferOpaqueCaptureAddressCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceImagelessFramebufferFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub imagelessFramebuffer: VkBool32,
}
impl VkPhysicalDeviceImagelessFramebufferFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferAttachmentsCreateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub attachmentImageInfoCount: u32,
    pub pAttachmentImageInfos: * const VkFramebufferAttachmentImageInfo,
}
impl VkFramebufferAttachmentsCreateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferAttachmentImageInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub flags: VkImageCreateFlagBits,
    pub usage: VkImageUsageFlagBits,
    pub width: u32,
    pub height: u32,
    pub layerCount: u32,
    pub viewFormatCount: u32,
    pub pViewFormats: * const VkFormat,
}
impl VkFramebufferAttachmentImageInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassAttachmentBeginInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub attachmentCount: u32,
    pub pAttachments: * const VkImageView,
}
impl VkRenderPassAttachmentBeginInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub separateDepthStencilLayouts: VkBool32,
}
impl VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentReferenceStencilLayout
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub stencilLayout: VkImageLayout,
}
impl VkAttachmentReferenceStencilLayout
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentDescriptionStencilLayout
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub stencilInitialLayout: VkImageLayout,
    pub stencilFinalLayout: VkImageLayout,
}
impl VkAttachmentDescriptionStencilLayout
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryOpaqueCaptureAddressAllocateInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub opaqueCaptureAddress: u64,
}
impl VkMemoryOpaqueCaptureAddressAllocateInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceMemoryOpaqueCaptureAddressInfo
{
    pub sType: VkStructureType,
    pub pNext: * const c_void,
    pub memory: VkDeviceMemory,
}
impl VkDeviceMemoryOpaqueCaptureAddressInfo
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVulkan11Features
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub storageBuffer16BitAccess: VkBool32,
    pub uniformAndStorageBuffer16BitAccess: VkBool32,
    pub storagePushConstant16: VkBool32,
    pub storageInputOutput16: VkBool32,
    pub multiview: VkBool32,
    pub multiviewGeometryShader: VkBool32,
    pub multiviewTessellationShader: VkBool32,
    pub variablePointersStorageBuffer: VkBool32,
    pub variablePointers: VkBool32,
    pub protectedMemory: VkBool32,
    pub samplerYcbcrConversion: VkBool32,
    pub shaderDrawParameters: VkBool32,
}
impl VkPhysicalDeviceVulkan11Features
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVulkan11Properties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub deviceUUID: [u8; VK_UUID_SIZE],
    pub driverUUID: [u8; VK_UUID_SIZE],
    pub deviceLUID: [u8; VK_LUID_SIZE],
    pub deviceNodeMask: u32,
    pub deviceLUIDValid: VkBool32,
    pub subgroupSize: u32,
    pub subgroupSupportedStages: VkShaderStageFlagBits,
    pub subgroupSupportedOperations: VkSubgroupFeatureFlagBits,
    pub subgroupQuadOperationsInAllStages: VkBool32,
    pub pointClippingBehavior: VkPointClippingBehavior,
    pub maxMultiviewViewCount: u32,
    pub maxMultiviewInstanceIndex: u32,
    pub protectedNoFault: VkBool32,
    pub maxPerSetDescriptors: u32,
    pub maxMemoryAllocationSize: VkDeviceSize,
}
impl VkPhysicalDeviceVulkan11Properties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVulkan12Features
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub samplerMirrorClampToEdge: VkBool32,
    pub drawIndirectCount: VkBool32,
    pub storageBuffer8BitAccess: VkBool32,
    pub uniformAndStorageBuffer8BitAccess: VkBool32,
    pub storagePushConstant8: VkBool32,
    pub shaderBufferInt64Atomics: VkBool32,
    pub shaderSharedInt64Atomics: VkBool32,
    pub shaderFloat16: VkBool32,
    pub shaderInt8: VkBool32,
    pub descriptorIndexing: VkBool32,
    pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
    pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
    pub descriptorBindingPartiallyBound: VkBool32,
    pub descriptorBindingVariableDescriptorCount: VkBool32,
    pub runtimeDescriptorArray: VkBool32,
    pub samplerFilterMinmax: VkBool32,
    pub scalarBlockLayout: VkBool32,
    pub imagelessFramebuffer: VkBool32,
    pub uniformBufferStandardLayout: VkBool32,
    pub shaderSubgroupExtendedTypes: VkBool32,
    pub separateDepthStencilLayouts: VkBool32,
    pub hostQueryReset: VkBool32,
    pub timelineSemaphore: VkBool32,
    pub bufferDeviceAddress: VkBool32,
    pub bufferDeviceAddressCaptureReplay: VkBool32,
    pub bufferDeviceAddressMultiDevice: VkBool32,
    pub vulkanMemoryModel: VkBool32,
    pub vulkanMemoryModelDeviceScope: VkBool32,
    pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
    pub shaderOutputViewportIndex: VkBool32,
    pub shaderOutputLayer: VkBool32,
    pub subgroupBroadcastDynamicId: VkBool32,
}
impl VkPhysicalDeviceVulkan12Features
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVulkan12Properties
{
    pub sType: VkStructureType,
    pub pNext: * mut c_void,
    pub driverID: VkDriverId,
    pub driverName: [c_uchar; VK_MAX_DRIVER_NAME_SIZE],
    pub driverInfo: [c_uchar; VK_MAX_DRIVER_INFO_SIZE],
    pub conformanceVersion: VkConformanceVersion,
    pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
    pub roundingModeIndependence: VkShaderFloatControlsIndependence,
    pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
    pub shaderDenormPreserveFloat16: VkBool32,
    pub shaderDenormPreserveFloat32: VkBool32,
    pub shaderDenormPreserveFloat64: VkBool32,
    pub shaderDenormFlushToZeroFloat16: VkBool32,
    pub shaderDenormFlushToZeroFloat32: VkBool32,
    pub shaderDenormFlushToZeroFloat64: VkBool32,
    pub shaderRoundingModeRTEFloat16: VkBool32,
    pub shaderRoundingModeRTEFloat32: VkBool32,
    pub shaderRoundingModeRTEFloat64: VkBool32,
    pub shaderRoundingModeRTZFloat16: VkBool32,
    pub shaderRoundingModeRTZFloat32: VkBool32,
    pub shaderRoundingModeRTZFloat64: VkBool32,
    pub maxUpdateAfterBindDescriptorsInAllPools: u32,
    pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
    pub robustBufferAccessUpdateAfterBind: VkBool32,
    pub quadDivergentImplicitLod: VkBool32,
    pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    pub maxPerStageUpdateAfterBindResources: u32,
    pub maxDescriptorSetUpdateAfterBindSamplers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
    pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
    pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
    pub supportedDepthResolveModes: VkResolveModeFlagBits,
    pub supportedStencilResolveModes: VkResolveModeFlagBits,
    pub independentResolveNone: VkBool32,
    pub independentResolve: VkBool32,
    pub filterMinmaxSingleComponentFormats: VkBool32,
    pub filterMinmaxImageComponentMapping: VkBool32,
    pub maxTimelineSemaphoreValueDifference: u64,
    pub framebufferIntegerColorSampleCounts: VkSampleCountFlagBits,
}
impl VkPhysicalDeviceVulkan12Properties
{
    pub fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;

        return s;
    }
}

