use std::{io::Read, mem};
use std::os::raw::*;
type u32 = VkBool32;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageLayout
{
	VK_IMAGE_LAYOUT_UNDEFINED = 0,
	VK_IMAGE_LAYOUT_GENERAL = 1,
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
	VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAttachmentLoadOp
{
	VK_ATTACHMENT_LOAD_OP_LOAD = 0,
	VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
	VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAttachmentStoreOp
{
	VK_ATTACHMENT_STORE_OP_STORE = 0,
	VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageType
{
	VK_IMAGE_TYPE_1D = 0,
	VK_IMAGE_TYPE_2D = 1,
	VK_IMAGE_TYPE_3D = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageTiling
{
	VK_IMAGE_TILING_OPTIMAL = 0,
	VK_IMAGE_TILING_LINEAR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageViewType
{
	VK_IMAGE_VIEW_TYPE_1D = 0,
	VK_IMAGE_VIEW_TYPE_2D = 1,
	VK_IMAGE_VIEW_TYPE_3D = 2,
	VK_IMAGE_VIEW_TYPE_CUBE = 3,
	VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
	VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandBufferLevel
{
	VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
	VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkComponentSwizzle
{
	VK_COMPONENT_SWIZZLE_IDENTITY = 0,
	VK_COMPONENT_SWIZZLE_ZERO = 1,
	VK_COMPONENT_SWIZZLE_ONE = 2,
	VK_COMPONENT_SWIZZLE_R = 3,
	VK_COMPONENT_SWIZZLE_G = 4,
	VK_COMPONENT_SWIZZLE_B = 5,
	VK_COMPONENT_SWIZZLE_A = 6,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorType
{
	VK_DESCRIPTOR_TYPE_SAMPLER = 0,
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryType
{
	VK_QUERY_TYPE_OCCLUSION = 0,
	VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
	VK_QUERY_TYPE_TIMESTAMP = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBorderColor
{
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
	VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
	VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineBindPoint
{
	VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
	VK_PIPELINE_BIND_POINT_COMPUTE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineCacheHeaderVersion
{
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPrimitiveTopology
{
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSharingMode
{
	VK_SHARING_MODE_EXCLUSIVE = 0,
	VK_SHARING_MODE_CONCURRENT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkIndexType
{
	VK_INDEX_TYPE_UINT16 = 0,
	VK_INDEX_TYPE_UINT32 = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFilter
{
	VK_FILTER_NEAREST = 0,
	VK_FILTER_LINEAR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerMipmapMode
{
	VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
	VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerAddressMode
{
	VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCompareOp
{
	VK_COMPARE_OP_NEVER = 0,
	VK_COMPARE_OP_LESS = 1,
	VK_COMPARE_OP_EQUAL = 2,
	VK_COMPARE_OP_LESS_OR_EQUAL = 3,
	VK_COMPARE_OP_GREATER = 4,
	VK_COMPARE_OP_NOT_EQUAL = 5,
	VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
	VK_COMPARE_OP_ALWAYS = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPolygonMode
{
	VK_POLYGON_MODE_FILL = 0,
	VK_POLYGON_MODE_LINE = 1,
	VK_POLYGON_MODE_POINT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFrontFace
{
	VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
	VK_FRONT_FACE_CLOCKWISE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBlendFactor
{
	VK_BLEND_FACTOR_ZERO = 0,
	VK_BLEND_FACTOR_ONE = 1,
	VK_BLEND_FACTOR_SRC_COLOR = 2,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
	VK_BLEND_FACTOR_DST_COLOR = 4,
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
	VK_BLEND_FACTOR_SRC_ALPHA = 6,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
	VK_BLEND_FACTOR_DST_ALPHA = 8,
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
	VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
	VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
	VK_BLEND_FACTOR_SRC1_COLOR = 15,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
	VK_BLEND_FACTOR_SRC1_ALPHA = 17,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBlendOp
{
	VK_BLEND_OP_ADD = 0,
	VK_BLEND_OP_SUBTRACT = 1,
	VK_BLEND_OP_REVERSE_SUBTRACT = 2,
	VK_BLEND_OP_MIN = 3,
	VK_BLEND_OP_MAX = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkStencilOp
{
	VK_STENCIL_OP_KEEP = 0,
	VK_STENCIL_OP_ZERO = 1,
	VK_STENCIL_OP_REPLACE = 2,
	VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
	VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
	VK_STENCIL_OP_INVERT = 5,
	VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
	VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkLogicOp
{
	VK_LOGIC_OP_CLEAR = 0,
	VK_LOGIC_OP_AND = 1,
	VK_LOGIC_OP_AND_REVERSE = 2,
	VK_LOGIC_OP_COPY = 3,
	VK_LOGIC_OP_AND_INVERTED = 4,
	VK_LOGIC_OP_NO_OP = 5,
	VK_LOGIC_OP_XOR = 6,
	VK_LOGIC_OP_OR = 7,
	VK_LOGIC_OP_NOR = 8,
	VK_LOGIC_OP_EQUIVALENT = 9,
	VK_LOGIC_OP_INVERT = 10,
	VK_LOGIC_OP_OR_REVERSE = 11,
	VK_LOGIC_OP_COPY_INVERTED = 12,
	VK_LOGIC_OP_OR_INVERTED = 13,
	VK_LOGIC_OP_NAND = 14,
	VK_LOGIC_OP_SET = 15,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkInternalAllocationType
{
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSystemAllocationScope
{
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPhysicalDeviceType
{
	VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
	VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVertexInputRate
{
	VK_VERTEX_INPUT_RATE_VERTEX = 0,
	VK_VERTEX_INPUT_RATE_INSTANCE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFormat
{
	VK_FORMAT_UNDEFINED = 0,
	VK_FORMAT_R4G4_UNORM_PACK8 = 1,
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
	VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
	VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
	VK_FORMAT_R8_UNORM = 9,
	VK_FORMAT_R8_SNORM = 10,
	VK_FORMAT_R8_USCALED = 11,
	VK_FORMAT_R8_SSCALED = 12,
	VK_FORMAT_R8_UINT = 13,
	VK_FORMAT_R8_SINT = 14,
	VK_FORMAT_R8_SRGB = 15,
	VK_FORMAT_R8G8_UNORM = 16,
	VK_FORMAT_R8G8_SNORM = 17,
	VK_FORMAT_R8G8_USCALED = 18,
	VK_FORMAT_R8G8_SSCALED = 19,
	VK_FORMAT_R8G8_UINT = 20,
	VK_FORMAT_R8G8_SINT = 21,
	VK_FORMAT_R8G8_SRGB = 22,
	VK_FORMAT_R8G8B8_UNORM = 23,
	VK_FORMAT_R8G8B8_SNORM = 24,
	VK_FORMAT_R8G8B8_USCALED = 25,
	VK_FORMAT_R8G8B8_SSCALED = 26,
	VK_FORMAT_R8G8B8_UINT = 27,
	VK_FORMAT_R8G8B8_SINT = 28,
	VK_FORMAT_R8G8B8_SRGB = 29,
	VK_FORMAT_B8G8R8_UNORM = 30,
	VK_FORMAT_B8G8R8_SNORM = 31,
	VK_FORMAT_B8G8R8_USCALED = 32,
	VK_FORMAT_B8G8R8_SSCALED = 33,
	VK_FORMAT_B8G8R8_UINT = 34,
	VK_FORMAT_B8G8R8_SINT = 35,
	VK_FORMAT_B8G8R8_SRGB = 36,
	VK_FORMAT_R8G8B8A8_UNORM = 37,
	VK_FORMAT_R8G8B8A8_SNORM = 38,
	VK_FORMAT_R8G8B8A8_USCALED = 39,
	VK_FORMAT_R8G8B8A8_SSCALED = 40,
	VK_FORMAT_R8G8B8A8_UINT = 41,
	VK_FORMAT_R8G8B8A8_SINT = 42,
	VK_FORMAT_R8G8B8A8_SRGB = 43,
	VK_FORMAT_B8G8R8A8_UNORM = 44,
	VK_FORMAT_B8G8R8A8_SNORM = 45,
	VK_FORMAT_B8G8R8A8_USCALED = 46,
	VK_FORMAT_B8G8R8A8_SSCALED = 47,
	VK_FORMAT_B8G8R8A8_UINT = 48,
	VK_FORMAT_B8G8R8A8_SINT = 49,
	VK_FORMAT_B8G8R8A8_SRGB = 50,
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
	VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
	VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
	VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
	VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
	VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
	VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
	VK_FORMAT_R16_UNORM = 70,
	VK_FORMAT_R16_SNORM = 71,
	VK_FORMAT_R16_USCALED = 72,
	VK_FORMAT_R16_SSCALED = 73,
	VK_FORMAT_R16_UINT = 74,
	VK_FORMAT_R16_SINT = 75,
	VK_FORMAT_R16_SFLOAT = 76,
	VK_FORMAT_R16G16_UNORM = 77,
	VK_FORMAT_R16G16_SNORM = 78,
	VK_FORMAT_R16G16_USCALED = 79,
	VK_FORMAT_R16G16_SSCALED = 80,
	VK_FORMAT_R16G16_UINT = 81,
	VK_FORMAT_R16G16_SINT = 82,
	VK_FORMAT_R16G16_SFLOAT = 83,
	VK_FORMAT_R16G16B16_UNORM = 84,
	VK_FORMAT_R16G16B16_SNORM = 85,
	VK_FORMAT_R16G16B16_USCALED = 86,
	VK_FORMAT_R16G16B16_SSCALED = 87,
	VK_FORMAT_R16G16B16_UINT = 88,
	VK_FORMAT_R16G16B16_SINT = 89,
	VK_FORMAT_R16G16B16_SFLOAT = 90,
	VK_FORMAT_R16G16B16A16_UNORM = 91,
	VK_FORMAT_R16G16B16A16_SNORM = 92,
	VK_FORMAT_R16G16B16A16_USCALED = 93,
	VK_FORMAT_R16G16B16A16_SSCALED = 94,
	VK_FORMAT_R16G16B16A16_UINT = 95,
	VK_FORMAT_R16G16B16A16_SINT = 96,
	VK_FORMAT_R16G16B16A16_SFLOAT = 97,
	VK_FORMAT_R32_UINT = 98,
	VK_FORMAT_R32_SINT = 99,
	VK_FORMAT_R32_SFLOAT = 100,
	VK_FORMAT_R32G32_UINT = 101,
	VK_FORMAT_R32G32_SINT = 102,
	VK_FORMAT_R32G32_SFLOAT = 103,
	VK_FORMAT_R32G32B32_UINT = 104,
	VK_FORMAT_R32G32B32_SINT = 105,
	VK_FORMAT_R32G32B32_SFLOAT = 106,
	VK_FORMAT_R32G32B32A32_UINT = 107,
	VK_FORMAT_R32G32B32A32_SINT = 108,
	VK_FORMAT_R32G32B32A32_SFLOAT = 109,
	VK_FORMAT_R64_UINT = 110,
	VK_FORMAT_R64_SINT = 111,
	VK_FORMAT_R64_SFLOAT = 112,
	VK_FORMAT_R64G64_UINT = 113,
	VK_FORMAT_R64G64_SINT = 114,
	VK_FORMAT_R64G64_SFLOAT = 115,
	VK_FORMAT_R64G64B64_UINT = 116,
	VK_FORMAT_R64G64B64_SINT = 117,
	VK_FORMAT_R64G64B64_SFLOAT = 118,
	VK_FORMAT_R64G64B64A64_UINT = 119,
	VK_FORMAT_R64G64B64A64_SINT = 120,
	VK_FORMAT_R64G64B64A64_SFLOAT = 121,
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
	VK_FORMAT_D16_UNORM = 124,
	VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
	VK_FORMAT_D32_SFLOAT = 126,
	VK_FORMAT_S8_UINT = 127,
	VK_FORMAT_D16_UNORM_S8_UINT = 128,
	VK_FORMAT_D24_UNORM_S8_UINT = 129,
	VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
	VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
	VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
	VK_FORMAT_BC2_UNORM_BLOCK = 135,
	VK_FORMAT_BC2_SRGB_BLOCK = 136,
	VK_FORMAT_BC3_UNORM_BLOCK = 137,
	VK_FORMAT_BC3_SRGB_BLOCK = 138,
	VK_FORMAT_BC4_UNORM_BLOCK = 139,
	VK_FORMAT_BC4_SNORM_BLOCK = 140,
	VK_FORMAT_BC5_UNORM_BLOCK = 141,
	VK_FORMAT_BC5_SNORM_BLOCK = 142,
	VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
	VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
	VK_FORMAT_BC7_UNORM_BLOCK = 145,
	VK_FORMAT_BC7_SRGB_BLOCK = 146,
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
	VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkStructureType
{
	VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
	VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSubpassContents
{
	VK_SUBPASS_CONTENTS_INLINE = 0,
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkResult
{
	VK_SUCCESS = 0,
	VK_NOT_READY = 1,
	VK_TIMEOUT = 2,
	VK_EVENT_SET = 3,
	VK_EVENT_RESET = 4,
	VK_INCOMPLETE = 5,
	VK_ERROR_OUT_OF_HOST_MEMORY = -1,
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
	VK_ERROR_INITIALIZATION_FAILED = -3,
	VK_ERROR_DEVICE_LOST = -4,
	VK_ERROR_MEMORY_MAP_FAILED = -5,
	VK_ERROR_LAYER_NOT_PRESENT = -6,
	VK_ERROR_EXTENSION_NOT_PRESENT = -7,
	VK_ERROR_FEATURE_NOT_PRESENT = -8,
	VK_ERROR_INCOMPATIBLE_DRIVER = -9,
	VK_ERROR_TOO_MANY_OBJECTS = -10,
	VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
	VK_ERROR_FRAGMENTED_POOL = -12,
	VK_ERROR_UNKNOWN = -13,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDynamicState
{
	VK_DYNAMIC_STATE_VIEWPORT = 0,
	VK_DYNAMIC_STATE_SCISSOR = 1,
	VK_DYNAMIC_STATE_LINE_WIDTH = 2,
	VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
	VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
	VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorUpdateTemplateType
{
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkObjectType
{
	VK_OBJECT_TYPE_UNKNOWN = 0,
	VK_OBJECT_TYPE_INSTANCE = 1,
	VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
	VK_OBJECT_TYPE_DEVICE = 3,
	VK_OBJECT_TYPE_QUEUE = 4,
	VK_OBJECT_TYPE_SEMAPHORE = 5,
	VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
	VK_OBJECT_TYPE_FENCE = 7,
	VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
	VK_OBJECT_TYPE_BUFFER = 9,
	VK_OBJECT_TYPE_IMAGE = 10,
	VK_OBJECT_TYPE_EVENT = 11,
	VK_OBJECT_TYPE_QUERY_POOL = 12,
	VK_OBJECT_TYPE_BUFFER_VIEW = 13,
	VK_OBJECT_TYPE_IMAGE_VIEW = 14,
	VK_OBJECT_TYPE_SHADER_MODULE = 15,
	VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
	VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
	VK_OBJECT_TYPE_RENDER_PASS = 18,
	VK_OBJECT_TYPE_PIPELINE = 19,
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
	VK_OBJECT_TYPE_SAMPLER = 21,
	VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
	VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
	VK_OBJECT_TYPE_FRAMEBUFFER = 24,
	VK_OBJECT_TYPE_COMMAND_POOL = 25,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSemaphoreType
{
	VK_SEMAPHORE_TYPE_BINARY = 0,
	VK_SEMAPHORE_TYPE_TIMELINE = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPresentModeKHR
{
	VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
	VK_PRESENT_MODE_MAILBOX_KHR = 1,
	VK_PRESENT_MODE_FIFO_KHR = 2,
	VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkColorSpaceKHR
{
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkTimeDomainEXT
{
	VK_TIME_DOMAIN_DEVICE_EXT = 0,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2,
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDebugReportObjectTypeEXT
{
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceMemoryReportEventTypeEXT
{
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkRasterizationOrderAMD
{
	VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
	VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkValidationCheckEXT
{
	VK_VALIDATION_CHECK_ALL_EXT = 0,
	VK_VALIDATION_CHECK_SHADERS_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkValidationFeatureEnableEXT
{
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
	VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
	VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
	VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkValidationFeatureDisableEXT
{
	VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
	VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
	VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
	VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
	VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
	VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
	VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
	VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkIndirectCommandsTokenTypeNV
{
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDisplayPowerStateEXT
{
	VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
	VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
	VK_DISPLAY_POWER_STATE_ON_EXT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceEventTypeEXT
{
	VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDisplayEventTypeEXT
{
	VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkViewportCoordinateSwizzleNV
{
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDiscardRectangleModeEXT
{
	VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
	VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPointClippingBehavior
{
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerReductionMode
{
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
	VK_SAMPLER_REDUCTION_MODE_MIN = 1,
	VK_SAMPLER_REDUCTION_MODE_MAX = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkTessellationDomainOrigin
{
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerYcbcrModelConversion
{
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerYcbcrRange
{
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkChromaLocation
{
	VK_CHROMA_LOCATION_COSITED_EVEN = 0,
	VK_CHROMA_LOCATION_MIDPOINT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBlendOverlapEXT
{
	VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
	VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
	VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCoverageModulationModeNV
{
	VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
	VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
	VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
	VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCoverageReductionModeNV
{
	VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
	VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkValidationCacheHeaderVersionEXT
{
	VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderInfoTypeAMD
{
	VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
	VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
	VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueueGlobalPriorityEXT
{
	VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkConservativeRasterizationModeEXT
{
	VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
	VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
	VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVendorId
{
	VK_VENDOR_ID_VIV = 0x10001,
	VK_VENDOR_ID_VSI = 0x10002,
	VK_VENDOR_ID_KAZAN = 0x10003,
	VK_VENDOR_ID_CODEPLAY = 0x10004,
	VK_VENDOR_ID_MESA = 0x10005,
	VK_VENDOR_ID_POCL = 0x10006,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDriverId
{
	VK_DRIVER_ID_AMD_PROPRIETARY = 1,
	VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
	VK_DRIVER_ID_MESA_RADV = 3,
	VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
	VK_DRIVER_ID_ARM_PROPRIETARY = 9,
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
	VK_DRIVER_ID_GGP_PROPRIETARY = 11,
	VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
	VK_DRIVER_ID_MESA_LLVMPIPE = 13,
	VK_DRIVER_ID_MOLTENVK = 14,
	VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
	VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
	VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShadingRatePaletteEntryNV
{
	VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
	VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
	VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
	VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
	VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCoarseSampleOrderTypeNV
{
	VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
	VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
	VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
	VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCopyAccelerationStructureModeKHR
{
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBuildAccelerationStructureModeKHR
{
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureTypeKHR
{
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
	VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkGeometryTypeKHR
{
	VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
	VK_GEOMETRY_TYPE_AABBS_KHR = 1,
	VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureMemoryRequirementsTypeNV
{
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureBuildTypeKHR
{
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkRayTracingShaderGroupTypeKHR
{
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureCompatibilityKHR
{
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderGroupShaderKHR
{
	VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
	VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
	VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
	VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkMemoryOverallocationBehaviorAMD
{
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkScopeNV
{
	VK_SCOPE_DEVICE_NV = 1,
	VK_SCOPE_WORKGROUP_NV = 2,
	VK_SCOPE_SUBGROUP_NV = 3,
	VK_SCOPE_QUEUE_FAMILY_NV = 5,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkComponentTypeNV
{
	VK_COMPONENT_TYPE_FLOAT16_NV = 0,
	VK_COMPONENT_TYPE_FLOAT32_NV = 1,
	VK_COMPONENT_TYPE_FLOAT64_NV = 2,
	VK_COMPONENT_TYPE_SINT8_NV = 3,
	VK_COMPONENT_TYPE_SINT16_NV = 4,
	VK_COMPONENT_TYPE_SINT32_NV = 5,
	VK_COMPONENT_TYPE_SINT64_NV = 6,
	VK_COMPONENT_TYPE_UINT8_NV = 7,
	VK_COMPONENT_TYPE_UINT16_NV = 8,
	VK_COMPONENT_TYPE_UINT32_NV = 9,
	VK_COMPONENT_TYPE_UINT64_NV = 10,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFullScreenExclusiveEXT
{
	VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
	VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
	VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
	VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceCounterScopeKHR
{
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
	VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceCounterUnitKHR
{
	VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
	VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
	VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
	VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
	VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
	VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
	VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
	VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
	VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceCounterStorageKHR
{
	VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
	VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceConfigurationTypeINTEL
{
	VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryPoolSamplingModeINTEL
{
	VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceOverrideTypeINTEL
{
	VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
	VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceParameterTypeINTEL
{
	VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
	VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceValueTypeINTEL
{
	VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
	VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
	VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
	VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
	VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderFloatControlsIndependence
{
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineExecutableStatisticFormatKHR
{
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkLineRasterizationModeEXT
{
	VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFragmentShadingRateCombinerOpKHR
{
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFragmentShadingRateNV
{
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
	VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
	VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
	VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
	VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
	VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFragmentShadingRateTypeNV
{
	VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
	VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkProvokingVertexModeEXT
{
	VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
	VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureMotionInstanceTypeNV
{
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryResultStatusKHR
{
	VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
	VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
	VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineCacheCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueueFlagBits
{
	VK_QUEUE_GRAPHICS_BIT = 1,
	VK_QUEUE_COMPUTE_BIT = 2,
	VK_QUEUE_TRANSFER_BIT = 4,
	VK_QUEUE_SPARSE_BINDING_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCullModeFlagBits
{
	VK_CULL_MODE_NONE = 0,
	VK_CULL_MODE_FRONT_BIT = 1,
	VK_CULL_MODE_BACK_BIT = 2,
	VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkRenderPassCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceQueueCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkMemoryPropertyFlagBits
{
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1,
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2,
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 4,
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 8,
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkMemoryHeapFlagBits
{
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccessFlagBits
{
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1,
	VK_ACCESS_INDEX_READ_BIT = 2,
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4,
	VK_ACCESS_UNIFORM_READ_BIT = 8,
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16,
	VK_ACCESS_SHADER_READ_BIT = 32,
	VK_ACCESS_SHADER_WRITE_BIT = 64,
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128,
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
	VK_ACCESS_TRANSFER_READ_BIT = 2048,
	VK_ACCESS_TRANSFER_WRITE_BIT = 4096,
	VK_ACCESS_HOST_READ_BIT = 8192,
	VK_ACCESS_HOST_WRITE_BIT = 16384,
	VK_ACCESS_MEMORY_READ_BIT = 32768,
	VK_ACCESS_MEMORY_WRITE_BIT = 65536,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBufferUsageFlagBits
{
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1,
	VK_BUFFER_USAGE_TRANSFER_DST_BIT = 2,
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4,
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8,
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16,
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 32,
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 64,
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 128,
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBufferCreateFlagBits
{
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1,
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 2,
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderStageFlagBits
{
	VK_SHADER_STAGE_VERTEX_BIT = 1,
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2,
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4,
	VK_SHADER_STAGE_GEOMETRY_BIT = 8,
	VK_SHADER_STAGE_FRAGMENT_BIT = 16,
	VK_SHADER_STAGE_COMPUTE_BIT = 32,
	VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
	VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageUsageFlagBits
{
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1,
	VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2,
	VK_IMAGE_USAGE_SAMPLED_BIT = 4,
	VK_IMAGE_USAGE_STORAGE_BIT = 8,
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16,
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32,
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64,
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageCreateFlagBits
{
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1,
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 2,
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 4,
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 8,
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageViewCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSamplerCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineCreateFlagBits
{
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1,
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 2,
	VK_PIPELINE_CREATE_DERIVATIVE_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineShaderStageCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkColorComponentFlagBits
{
	VK_COLOR_COMPONENT_R_BIT = 1,
	VK_COLOR_COMPONENT_G_BIT = 2,
	VK_COLOR_COMPONENT_B_BIT = 4,
	VK_COLOR_COMPONENT_A_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFenceCreateFlagBits
{
	VK_FENCE_CREATE_SIGNALED_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSemaphoreCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFormatFeatureFlagBits
{
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 2,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 4,
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 8,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 16,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 64,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 128,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 256,
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 512,
	VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1024,
	VK_FORMAT_FEATURE_BLIT_DST_BIT = 2048,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryControlFlagBits
{
	VK_QUERY_CONTROL_PRECISE_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryResultFlagBits
{
	VK_QUERY_RESULT_64_BIT = 1,
	VK_QUERY_RESULT_WAIT_BIT = 2,
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 4,
	VK_QUERY_RESULT_PARTIAL_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandBufferUsageFlagBits
{
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1,
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2,
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkQueryPipelineStatisticFlagBits
{
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1,
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 4,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 32,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 64,
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 512,
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1024,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkImageAspectFlagBits
{
	VK_IMAGE_ASPECT_COLOR_BIT = 1,
	VK_IMAGE_ASPECT_DEPTH_BIT = 2,
	VK_IMAGE_ASPECT_STENCIL_BIT = 4,
	VK_IMAGE_ASPECT_METADATA_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSparseImageFormatFlagBits
{
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1,
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 2,
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSparseMemoryBindFlagBits
{
	VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineStageFlagBits
{
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1,
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 2,
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 4,
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 8,
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 16,
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 32,
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 64,
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 128,
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 256,
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 512,
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 2048,
	VK_PIPELINE_STAGE_TRANSFER_BIT = 4096,
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 8192,
	VK_PIPELINE_STAGE_HOST_BIT = 16384,
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 32768,
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 65536,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandPoolCreateFlagBits
{
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1,
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandPoolResetFlagBits
{
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCommandBufferResetFlagBits
{
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSampleCountFlagBits
{
	VK_SAMPLE_COUNT_1_BIT = 1,
	VK_SAMPLE_COUNT_2_BIT = 2,
	VK_SAMPLE_COUNT_4_BIT = 4,
	VK_SAMPLE_COUNT_8_BIT = 8,
	VK_SAMPLE_COUNT_16_BIT = 16,
	VK_SAMPLE_COUNT_32_BIT = 32,
	VK_SAMPLE_COUNT_64_BIT = 64,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAttachmentDescriptionFlagBits
{
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkStencilFaceFlagBits
{
	VK_STENCIL_FACE_FRONT_BIT = 1,
	VK_STENCIL_FACE_BACK_BIT = 2,
	VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorPoolCreateFlagBits
{
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDependencyFlagBits
{
	VK_DEPENDENCY_BY_REGION_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSemaphoreWaitFlagBits
{
	VK_SEMAPHORE_WAIT_ANY_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDisplayPlaneAlphaFlagBitsKHR
{
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1,
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 2,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 4,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkCompositeAlphaFlagBitsKHR
{
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1,
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 2,
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 4,
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSurfaceTransformFlagBitsKHR
{
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1,
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 2,
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 4,
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 8,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 16,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 256,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSwapchainImageUsageFlagBitsANDROID
{
	VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDebugReportFlagBitsEXT
{
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1,
	VK_DEBUG_REPORT_WARNING_BIT_EXT = 2,
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 4,
	VK_DEBUG_REPORT_ERROR_BIT_EXT = 8,
	VK_DEBUG_REPORT_DEBUG_BIT_EXT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalMemoryHandleTypeFlagBitsNV
{
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 1,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 2,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 4,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalMemoryFeatureFlagBitsNV
{
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 1,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 2,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSubgroupFeatureFlagBits
{
	VK_SUBGROUP_FEATURE_BASIC_BIT = 1,
	VK_SUBGROUP_FEATURE_VOTE_BIT = 2,
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 4,
	VK_SUBGROUP_FEATURE_BALLOT_BIT = 8,
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 16,
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 32,
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 64,
	VK_SUBGROUP_FEATURE_QUAD_BIT = 128,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkIndirectCommandsLayoutUsageFlagBitsNV
{
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 1,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 2,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkIndirectStateFlagBitsNV
{
	VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPrivateDataSlotCreateFlagBitsEXT
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorSetLayoutCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalMemoryHandleTypeFlagBits
{
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 8,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 16,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 32,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 64,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalMemoryFeatureFlagBits
{
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 1,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 2,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalSemaphoreHandleTypeFlagBits
{
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 8,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalSemaphoreFeatureFlagBits
{
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 1,
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSemaphoreImportFlagBits
{
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalFenceHandleTypeFlagBits
{
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkExternalFenceFeatureFlagBits
{
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 1,
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFenceImportFlagBits
{
	VK_FENCE_IMPORT_TEMPORARY_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSurfaceCounterFlagBitsEXT
{
	VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPeerMemoryFeatureFlagBits
{
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 1,
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 2,
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 4,
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkMemoryAllocateFlagBits
{
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceGroupPresentModeFlagBitsKHR
{
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 1,
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 2,
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 4,
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSwapchainCreateFlagBitsKHR
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSubpassDescriptionFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDebugUtilsMessageSeverityFlagBitsEXT
{
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 1,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 16,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 256,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 4096,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDebugUtilsMessageTypeFlagBitsEXT
{
	VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 1,
	VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 2,
	VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDescriptorBindingFlagBits
{
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 1,
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 2,
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 4,
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkConditionalRenderingFlagBitsEXT
{
	VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkResolveModeFlagBits
{
	VK_RESOLVE_MODE_NONE = 0,
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 1,
	VK_RESOLVE_MODE_AVERAGE_BIT = 2,
	VK_RESOLVE_MODE_MIN_BIT = 4,
	VK_RESOLVE_MODE_MAX_BIT = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkGeometryInstanceFlagBitsKHR
{
	VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 1,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 2,
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 4,
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkGeometryFlagBitsKHR
{
	VK_GEOMETRY_OPAQUE_BIT_KHR = 1,
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkBuildAccelerationStructureFlagBitsKHR
{
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 1,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 2,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 4,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 8,
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccelerationStructureCreateFlagBitsKHR
{
	VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkFramebufferCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkDeviceDiagnosticsConfigFlagBitsNV
{
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 1,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 2,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineCreationFeedbackFlagBitsEXT
{
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 1,
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 2,
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPerformanceCounterDescriptionFlagBitsKHR
{
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 1,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAcquireProfilingLockFlagBitsKHR
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderCorePropertiesFlagBitsAMD
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkShaderModuleCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineCompilerControlFlagBitsAMD
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkToolPurposeFlagBitsEXT
{
	VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = 1,
	VK_TOOL_PURPOSE_PROFILING_BIT_EXT = 2,
	VK_TOOL_PURPOSE_TRACING_BIT_EXT = 4,
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 8,
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkAccessFlagBits2KHR
{
	VK_ACCESS_2_NONE_KHR = 0,
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 1,
	VK_ACCESS_2_INDEX_READ_BIT_KHR = 2,
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 4,
	VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 8,
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 16,
	VK_ACCESS_2_SHADER_READ_BIT_KHR = 32,
	VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 64,
	VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 128,
	VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 256,
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 512,
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 1024,
	VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 2048,
	VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 4096,
	VK_ACCESS_2_HOST_READ_BIT_KHR = 8192,
	VK_ACCESS_2_HOST_WRITE_BIT_KHR = 16384,
	VK_ACCESS_2_MEMORY_READ_BIT_KHR = 32768,
	VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 65536,
	VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 4294967296,
	VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 8589934592,
	VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 17179869184,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineStageFlagBits2KHR
{
	VK_PIPELINE_STAGE_2_NONE_KHR = 0,
	VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 1,
	VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 2,
	VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 4,
	VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 8,
	VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 16,
	VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 32,
	VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 64,
	VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 128,
	VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 256,
	VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 512,
	VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 1024,
	VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 2048,
	VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 4096,
	VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 8192,
	VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 16384,
	VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 32768,
	VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 65536,
	VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 4294967296,
	VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 8589934592,
	VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 17179869184,
	VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 34359738368,
	VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 68719476736,
	VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 137438953472,
	VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 274877906944,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkSubmitFlagBitsKHR
{
	VK_SUBMIT_PROTECTED_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkEventCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkPipelineLayoutCreateFlagBits
{
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoCodecOperationFlagBitsKHR
{
	VK_VIDEO_CODEC_OPERATION_INVALID_BIT_KHR = 0,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoChromaSubsamplingFlagBitsKHR
{
	VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_BIT_KHR = 0,
	VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 1,
	VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 2,
	VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 4,
	VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 8,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoComponentBitDepthFlagBitsKHR
{
	VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
	VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 1,
	VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 4,
	VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 16,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoCapabilityFlagBitsKHR
{
	VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 1,
	VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoSessionCreateFlagBitsKHR
{
	VK_VIDEO_SESSION_CREATE_DEFAULT_KHR = 0,
	VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoCodingQualityPresetFlagBitsKHR
{
	VK_VIDEO_CODING_QUALITY_PRESET_NORMAL_BIT_KHR = 1,
	VK_VIDEO_CODING_QUALITY_PRESET_POWER_BIT_KHR = 2,
	VK_VIDEO_CODING_QUALITY_PRESET_QUALITY_BIT_KHR = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoDecodeH264PictureLayoutFlagBitsEXT
{
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT = 0,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_EXT = 1,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_EXT = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoCodingControlFlagBitsKHR
{
	VK_VIDEO_CODING_CONTROL_DEFAULT_KHR = 0,
	VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoDecodeFlagBitsKHR
{
	VK_VIDEO_DECODE_DEFAULT_KHR = 0,
	VK_VIDEO_DECODE_RESERVED_0_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeFlagBitsKHR
{
	VK_VIDEO_ENCODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_RESERVED_0_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeRateControlFlagBitsKHR
{
	VK_VIDEO_ENCODE_RATE_CONTROL_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_RATE_CONTROL_RESET_BIT_KHR = 1,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeRateControlModeFlagBitsKHR
{
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR = 0,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 1,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 2,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeH264CapabilityFlagBitsEXT
{
	VK_VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT = 1,
	VK_VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT = 2,
	VK_VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BI_PRED_IMPLICIT_BIT_EXT = 4,
	VK_VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT = 8,
	VK_VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT = 16,
	VK_VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT = 32,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_DISABLED_BIT_EXT = 64,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_ENABLED_BIT_EXT = 128,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = 256,
	VK_VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICE_PER_FRAME_BIT_EXT = 512,
	VK_VIDEO_ENCODE_H264_CAPABILITY_EVENLY_DISTRIBUTED_SLICE_SIZE_BIT_EXT = 1024,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeH264InputModeFlagBitsEXT
{
	VK_VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT = 1,
	VK_VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT = 2,
	VK_VIDEO_ENCODE_H264_INPUT_MODE_NON_VCL_BIT_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeH264OutputModeFlagBitsEXT
{
	VK_VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT = 1,
	VK_VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT = 2,
	VK_VIDEO_ENCODE_H264_OUTPUT_MODE_NON_VCL_BIT_EXT = 4,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum VkVideoEncodeH264CreateFlagBitsEXT
{
	VK_VIDEO_ENCODE_H264_CREATE_DEFAULT_EXT = 0,
	VK_VIDEO_ENCODE_H264_CREATE_RESERVED_0_BIT_EXT = 1,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBaseOutStructure
{
	sType: VkStructureType,
	pNext: * const VkBaseOutStructure,
}
impl VkBaseOutStructure
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBaseInStructure
{
	sType: VkStructureType,
	pNext: * const VkBaseInStructure,
}
impl VkBaseInStructure
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkOffset2D
{
	x: i32,
	y: i32,
}
impl VkOffset2D
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkOffset3D
{
	x: i32,
	y: i32,
	z: i32,
}
impl VkOffset3D
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExtent2D
{
	width: u32,
	height: u32,
}
impl VkExtent2D
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExtent3D
{
	width: u32,
	height: u32,
	depth: u32,
}
impl VkExtent3D
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkViewport
{
	x: f32,
	y: f32,
	width: f32,
	height: f32,
	minDepth: f32,
	maxDepth: f32,
}
impl VkViewport
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRect2D
{
	offset: VkOffset2D,
	extent: VkExtent2D,
}
impl VkRect2D
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearRect
{
	rect: VkRect2D,
	baseArrayLayer: u32,
	layerCount: u32,
}
impl VkClearRect
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkComponentMapping
{
	r: VkComponentSwizzle,
	g: VkComponentSwizzle,
	b: VkComponentSwizzle,
	a: VkComponentSwizzle,
}
impl VkComponentMapping
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProperties
{
	apiVersion: u32,
	driverVersion: u32,
	vendorID: u32,
	deviceID: u32,
	deviceType: VkPhysicalDeviceType,
	deviceName: c_char,
	pipelineCacheUUID: u8,
	limits: VkPhysicalDeviceLimits,
	sparseProperties: VkPhysicalDeviceSparseProperties,
}
impl VkPhysicalDeviceProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExtensionProperties
{
	extensionName: c_char,
	specVersion: u32,
}
impl VkExtensionProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkLayerProperties
{
	layerName: c_char,
	specVersion: u32,
	implementationVersion: u32,
	description: c_char,
}
impl VkLayerProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkApplicationInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	pApplicationName: * const c_char,
	applicationVersion: u32,
	pEngineName: * const c_char,
	engineVersion: u32,
	apiVersion: u32,
}
impl VkApplicationInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAllocationCallbacks
{
	pUserData: * const c_void,
	pfnAllocation: PFN_vkAllocationFunction,
	pfnReallocation: PFN_vkReallocationFunction,
	pfnFree: PFN_vkFreeFunction,
	pfnInternalAllocation: PFN_vkInternalAllocationNotification,
	pfnInternalFree: PFN_vkInternalFreeNotification,
}
impl VkAllocationCallbacks
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceQueueCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDeviceQueueCreateFlags,
	queueFamilyIndex: u32,
	queueCount: u32,
	pQueuePriorities: * const f32,
}
impl VkDeviceQueueCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDeviceCreateFlags,
	queueCreateInfoCount: u32,
	pQueueCreateInfos: * const VkDeviceQueueCreateInfo,
	enabledLayerCount: u32,
	ppEnabledLayerNames: * const * const c_char,
	enabledExtensionCount: u32,
	ppEnabledExtensionNames: * const * const c_char,
	pEnabledFeatures: * const VkPhysicalDeviceFeatures,
}
impl VkDeviceCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInstanceCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkInstanceCreateFlags,
	pApplicationInfo: * const VkApplicationInfo,
	enabledLayerCount: u32,
	ppEnabledLayerNames: * const * const c_char,
	enabledExtensionCount: u32,
	ppEnabledExtensionNames: * const * const c_char,
}
impl VkInstanceCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueueFamilyProperties
{
	queueFlags: VkQueueFlags,
	queueCount: u32,
	timestampValidBits: u32,
	minImageTransferGranularity: VkExtent3D,
}
impl VkQueueFamilyProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties
{
	memoryTypeCount: u32,
	memoryTypes: VkMemoryType,
	memoryHeapCount: u32,
	memoryHeaps: VkMemoryHeap,
}
impl VkPhysicalDeviceMemoryProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryAllocateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	allocationSize: VkDeviceSize,
	memoryTypeIndex: u32,
}
impl VkMemoryAllocateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryRequirements
{
	size: VkDeviceSize,
	alignment: VkDeviceSize,
	memoryTypeBits: u32,
}
impl VkMemoryRequirements
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageFormatProperties
{
	aspectMask: VkImageAspectFlags,
	imageGranularity: VkExtent3D,
	flags: VkSparseImageFormatFlags,
}
impl VkSparseImageFormatProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryRequirements
{
	formatProperties: VkSparseImageFormatProperties,
	imageMipTailFirstLod: u32,
	imageMipTailSize: VkDeviceSize,
	imageMipTailOffset: VkDeviceSize,
	imageMipTailStride: VkDeviceSize,
}
impl VkSparseImageMemoryRequirements
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryType
{
	propertyFlags: VkMemoryPropertyFlags,
	heapIndex: u32,
}
impl VkMemoryType
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryHeap
{
	size: VkDeviceSize,
	flags: VkMemoryHeapFlags,
}
impl VkMemoryHeap
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMappedMemoryRange
{
	sType: VkStructureType,
	pNext: * const c_void,
	memory: VkDeviceMemory,
	offset: VkDeviceSize,
	size: VkDeviceSize,
}
impl VkMappedMemoryRange
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFormatProperties
{
	linearTilingFeatures: VkFormatFeatureFlags,
	optimalTilingFeatures: VkFormatFeatureFlags,
	bufferFeatures: VkFormatFeatureFlags,
}
impl VkFormatProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageFormatProperties
{
	maxExtent: VkExtent3D,
	maxMipLevels: u32,
	maxArrayLayers: u32,
	sampleCounts: VkSampleCountFlags,
	maxResourceSize: VkDeviceSize,
}
impl VkImageFormatProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorBufferInfo
{
	buffer: VkBuffer,
	offset: VkDeviceSize,
	range: VkDeviceSize,
}
impl VkDescriptorBufferInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorImageInfo
{
	sampler: VkSampler,
	imageView: VkImageView,
	imageLayout: VkImageLayout,
}
impl VkDescriptorImageInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkWriteDescriptorSet
{
	sType: VkStructureType,
	pNext: * const c_void,
	dstSet: VkDescriptorSet,
	dstBinding: u32,
	dstArrayElement: u32,
	descriptorCount: u32,
	descriptorType: VkDescriptorType,
	pImageInfo: * const VkDescriptorImageInfo,
	pBufferInfo: * const VkDescriptorBufferInfo,
	pTexelBufferView: * const VkBufferView,
}
impl VkWriteDescriptorSet
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyDescriptorSet
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcSet: VkDescriptorSet,
	srcBinding: u32,
	srcArrayElement: u32,
	dstSet: VkDescriptorSet,
	dstBinding: u32,
	dstArrayElement: u32,
	descriptorCount: u32,
}
impl VkCopyDescriptorSet
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkBufferCreateFlags,
	size: VkDeviceSize,
	usage: VkBufferUsageFlags,
	sharingMode: VkSharingMode,
	queueFamilyIndexCount: u32,
	pQueueFamilyIndices: * const u32,
}
impl VkBufferCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferViewCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkBufferViewCreateFlags,
	buffer: VkBuffer,
	format: VkFormat,
	offset: VkDeviceSize,
	range: VkDeviceSize,
}
impl VkBufferViewCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSubresource
{
	aspectMask: VkImageAspectFlags,
	mipLevel: u32,
	arrayLayer: u32,
}
impl VkImageSubresource
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSubresourceLayers
{
	aspectMask: VkImageAspectFlags,
	mipLevel: u32,
	baseArrayLayer: u32,
	layerCount: u32,
}
impl VkImageSubresourceLayers
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSubresourceRange
{
	aspectMask: VkImageAspectFlags,
	baseMipLevel: u32,
	levelCount: u32,
	baseArrayLayer: u32,
	layerCount: u32,
}
impl VkImageSubresourceRange
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryBarrier
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcAccessMask: VkAccessFlags,
	dstAccessMask: VkAccessFlags,
}
impl VkMemoryBarrier
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_BARRIER;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferMemoryBarrier
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcAccessMask: VkAccessFlags,
	dstAccessMask: VkAccessFlags,
	srcQueueFamilyIndex: u32,
	dstQueueFamilyIndex: u32,
	buffer: VkBuffer,
	offset: VkDeviceSize,
	size: VkDeviceSize,
}
impl VkBufferMemoryBarrier
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageMemoryBarrier
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcAccessMask: VkAccessFlags,
	dstAccessMask: VkAccessFlags,
	oldLayout: VkImageLayout,
	newLayout: VkImageLayout,
	srcQueueFamilyIndex: u32,
	dstQueueFamilyIndex: u32,
	image: VkImage,
	subresourceRange: VkImageSubresourceRange,
}
impl VkImageMemoryBarrier
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkImageCreateFlags,
	imageType: VkImageType,
	format: VkFormat,
	extent: VkExtent3D,
	mipLevels: u32,
	arrayLayers: u32,
	samples: VkSampleCountFlagBits,
	tiling: VkImageTiling,
	usage: VkImageUsageFlags,
	sharingMode: VkSharingMode,
	queueFamilyIndexCount: u32,
	pQueueFamilyIndices: * const u32,
	initialLayout: VkImageLayout,
}
impl VkImageCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubresourceLayout
{
	offset: VkDeviceSize,
	size: VkDeviceSize,
	rowPitch: VkDeviceSize,
	arrayPitch: VkDeviceSize,
	depthPitch: VkDeviceSize,
}
impl VkSubresourceLayout
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageViewCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkImageViewCreateFlags,
	image: VkImage,
	viewType: VkImageViewType,
	format: VkFormat,
	components: VkComponentMapping,
	subresourceRange: VkImageSubresourceRange,
}
impl VkImageViewCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferCopy
{
	srcOffset: VkDeviceSize,
	dstOffset: VkDeviceSize,
	size: VkDeviceSize,
}
impl VkBufferCopy
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseMemoryBind
{
	resourceOffset: VkDeviceSize,
	size: VkDeviceSize,
	memory: VkDeviceMemory,
	memoryOffset: VkDeviceSize,
	flags: VkSparseMemoryBindFlags,
}
impl VkSparseMemoryBind
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryBind
{
	subresource: VkImageSubresource,
	offset: VkOffset3D,
	extent: VkExtent3D,
	memory: VkDeviceMemory,
	memoryOffset: VkDeviceSize,
	flags: VkSparseMemoryBindFlags,
}
impl VkSparseImageMemoryBind
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseBufferMemoryBindInfo
{
	buffer: VkBuffer,
	bindCount: u32,
	pBinds: * const VkSparseMemoryBind,
}
impl VkSparseBufferMemoryBindInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageOpaqueMemoryBindInfo
{
	image: VkImage,
	bindCount: u32,
	pBinds: * const VkSparseMemoryBind,
}
impl VkSparseImageOpaqueMemoryBindInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryBindInfo
{
	image: VkImage,
	bindCount: u32,
	pBinds: * const VkSparseImageMemoryBind,
}
impl VkSparseImageMemoryBindInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindSparseInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	waitSemaphoreCount: u32,
	pWaitSemaphores: * const VkSemaphore,
	bufferBindCount: u32,
	pBufferBinds: * const VkSparseBufferMemoryBindInfo,
	imageOpaqueBindCount: u32,
	pImageOpaqueBinds: * const VkSparseImageOpaqueMemoryBindInfo,
	imageBindCount: u32,
	pImageBinds: * const VkSparseImageMemoryBindInfo,
	signalSemaphoreCount: u32,
	pSignalSemaphores: * const VkSemaphore,
}
impl VkBindSparseInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageCopy
{
	srcSubresource: VkImageSubresourceLayers,
	srcOffset: VkOffset3D,
	dstSubresource: VkImageSubresourceLayers,
	dstOffset: VkOffset3D,
	extent: VkExtent3D,
}
impl VkImageCopy
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageBlit
{
	srcSubresource: VkImageSubresourceLayers,
	srcOffsets: VkOffset3D,
	dstSubresource: VkImageSubresourceLayers,
	dstOffsets: VkOffset3D,
}
impl VkImageBlit
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferImageCopy
{
	bufferOffset: VkDeviceSize,
	bufferRowLength: u32,
	bufferImageHeight: u32,
	imageSubresource: VkImageSubresourceLayers,
	imageOffset: VkOffset3D,
	imageExtent: VkExtent3D,
}
impl VkBufferImageCopy
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageResolve
{
	srcSubresource: VkImageSubresourceLayers,
	srcOffset: VkOffset3D,
	dstSubresource: VkImageSubresourceLayers,
	dstOffset: VkOffset3D,
	extent: VkExtent3D,
}
impl VkImageResolve
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkShaderModuleCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkShaderModuleCreateFlags,
	codeSize: size_t,
	pCode: * const u32,
}
impl VkShaderModuleCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutBinding
{
	binding: u32,
	descriptorType: VkDescriptorType,
	descriptorCount: u32,
	stageFlags: VkShaderStageFlags,
	pImmutableSamplers: * const VkSampler,
}
impl VkDescriptorSetLayoutBinding
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDescriptorSetLayoutCreateFlags,
	bindingCount: u32,
	pBindings: * const VkDescriptorSetLayoutBinding,
}
impl VkDescriptorSetLayoutCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorPoolSize
{
	type: VkDescriptorType,
	descriptorCount: u32,
}
impl VkDescriptorPoolSize
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorPoolCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDescriptorPoolCreateFlags,
	maxSets: u32,
	poolSizeCount: u32,
	pPoolSizes: * const VkDescriptorPoolSize,
}
impl VkDescriptorPoolCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetAllocateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	descriptorPool: VkDescriptorPool,
	descriptorSetCount: u32,
	pSetLayouts: * const VkDescriptorSetLayout,
}
impl VkDescriptorSetAllocateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSpecializationMapEntry
{
	constantID: u32,
	offset: u32,
	size: size_t,
}
impl VkSpecializationMapEntry
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSpecializationInfo
{
	mapEntryCount: u32,
	pMapEntries: * const VkSpecializationMapEntry,
	dataSize: size_t,
	pData: * const c_void,
}
impl VkSpecializationInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineShaderStageCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineShaderStageCreateFlags,
	stage: VkShaderStageFlagBits,
	module: VkShaderModule,
	pName: * const c_char,
	pSpecializationInfo: * const VkSpecializationInfo,
}
impl VkPipelineShaderStageCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkComputePipelineCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineCreateFlags,
	stage: VkPipelineShaderStageCreateInfo,
	layout: VkPipelineLayout,
	basePipelineHandle: VkPipeline,
	basePipelineIndex: i32,
}
impl VkComputePipelineCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVertexInputBindingDescription
{
	binding: u32,
	stride: u32,
	inputRate: VkVertexInputRate,
}
impl VkVertexInputBindingDescription
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVertexInputAttributeDescription
{
	location: u32,
	binding: u32,
	format: VkFormat,
	offset: u32,
}
impl VkVertexInputAttributeDescription
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineVertexInputStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineVertexInputStateCreateFlags,
	vertexBindingDescriptionCount: u32,
	pVertexBindingDescriptions: * const VkVertexInputBindingDescription,
	vertexAttributeDescriptionCount: u32,
	pVertexAttributeDescriptions: * const VkVertexInputAttributeDescription,
}
impl VkPipelineVertexInputStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineInputAssemblyStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineInputAssemblyStateCreateFlags,
	topology: VkPrimitiveTopology,
	primitiveRestartEnable: VkBool32,
}
impl VkPipelineInputAssemblyStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineTessellationStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineTessellationStateCreateFlags,
	patchControlPoints: u32,
}
impl VkPipelineTessellationStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineViewportStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineViewportStateCreateFlags,
	viewportCount: u32,
	pViewports: * const VkViewport,
	scissorCount: u32,
	pScissors: * const VkRect2D,
}
impl VkPipelineViewportStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineRasterizationStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineRasterizationStateCreateFlags,
	depthClampEnable: VkBool32,
	rasterizerDiscardEnable: VkBool32,
	polygonMode: VkPolygonMode,
	cullMode: VkCullModeFlags,
	frontFace: VkFrontFace,
	depthBiasEnable: VkBool32,
	depthBiasConstantFactor: f32,
	depthBiasClamp: f32,
	depthBiasSlopeFactor: f32,
	lineWidth: f32,
}
impl VkPipelineRasterizationStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineMultisampleStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineMultisampleStateCreateFlags,
	rasterizationSamples: VkSampleCountFlagBits,
	sampleShadingEnable: VkBool32,
	minSampleShading: f32,
	pSampleMask: * const VkSampleMask,
	alphaToCoverageEnable: VkBool32,
	alphaToOneEnable: VkBool32,
}
impl VkPipelineMultisampleStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineColorBlendAttachmentState
{
	blendEnable: VkBool32,
	srcColorBlendFactor: VkBlendFactor,
	dstColorBlendFactor: VkBlendFactor,
	colorBlendOp: VkBlendOp,
	srcAlphaBlendFactor: VkBlendFactor,
	dstAlphaBlendFactor: VkBlendFactor,
	alphaBlendOp: VkBlendOp,
	colorWriteMask: VkColorComponentFlags,
}
impl VkPipelineColorBlendAttachmentState
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineColorBlendStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineColorBlendStateCreateFlags,
	logicOpEnable: VkBool32,
	logicOp: VkLogicOp,
	attachmentCount: u32,
	pAttachments: * const VkPipelineColorBlendAttachmentState,
	blendConstants: f32,
}
impl VkPipelineColorBlendStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineDynamicStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineDynamicStateCreateFlags,
	dynamicStateCount: u32,
	pDynamicStates: * const VkDynamicState,
}
impl VkPipelineDynamicStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkStencilOpState
{
	failOp: VkStencilOp,
	passOp: VkStencilOp,
	depthFailOp: VkStencilOp,
	compareOp: VkCompareOp,
	compareMask: u32,
	writeMask: u32,
	reference: u32,
}
impl VkStencilOpState
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineDepthStencilStateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineDepthStencilStateCreateFlags,
	depthTestEnable: VkBool32,
	depthWriteEnable: VkBool32,
	depthCompareOp: VkCompareOp,
	depthBoundsTestEnable: VkBool32,
	stencilTestEnable: VkBool32,
	front: VkStencilOpState,
	back: VkStencilOpState,
	minDepthBounds: f32,
	maxDepthBounds: f32,
}
impl VkPipelineDepthStencilStateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGraphicsPipelineCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineCreateFlags,
	stageCount: u32,
	pStages: * const VkPipelineShaderStageCreateInfo,
	pVertexInputState: * const VkPipelineVertexInputStateCreateInfo,
	pInputAssemblyState: * const VkPipelineInputAssemblyStateCreateInfo,
	pTessellationState: * const VkPipelineTessellationStateCreateInfo,
	pViewportState: * const VkPipelineViewportStateCreateInfo,
	pRasterizationState: * const VkPipelineRasterizationStateCreateInfo,
	pMultisampleState: * const VkPipelineMultisampleStateCreateInfo,
	pDepthStencilState: * const VkPipelineDepthStencilStateCreateInfo,
	pColorBlendState: * const VkPipelineColorBlendStateCreateInfo,
	pDynamicState: * const VkPipelineDynamicStateCreateInfo,
	layout: VkPipelineLayout,
	renderPass: VkRenderPass,
	subpass: u32,
	basePipelineHandle: VkPipeline,
	basePipelineIndex: i32,
}
impl VkGraphicsPipelineCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineCacheCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineCacheCreateFlags,
	initialDataSize: size_t,
	pInitialData: * const c_void,
}
impl VkPipelineCacheCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineCacheHeaderVersionOne
{
	headerSize: u32,
	headerVersion: VkPipelineCacheHeaderVersion,
	vendorID: u32,
	deviceID: u32,
	pipelineCacheUUID: u8,
}
impl VkPipelineCacheHeaderVersionOne
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPushConstantRange
{
	stageFlags: VkShaderStageFlags,
	offset: u32,
	size: u32,
}
impl VkPushConstantRange
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineLayoutCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineLayoutCreateFlags,
	setLayoutCount: u32,
	pSetLayouts: * const VkDescriptorSetLayout,
	pushConstantRangeCount: u32,
	pPushConstantRanges: * const VkPushConstantRange,
}
impl VkPipelineLayoutCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkSamplerCreateFlags,
	magFilter: VkFilter,
	minFilter: VkFilter,
	mipmapMode: VkSamplerMipmapMode,
	addressModeU: VkSamplerAddressMode,
	addressModeV: VkSamplerAddressMode,
	addressModeW: VkSamplerAddressMode,
	mipLodBias: f32,
	anisotropyEnable: VkBool32,
	maxAnisotropy: f32,
	compareEnable: VkBool32,
	compareOp: VkCompareOp,
	minLod: f32,
	maxLod: f32,
	borderColor: VkBorderColor,
	unnormalizedCoordinates: VkBool32,
}
impl VkSamplerCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandPoolCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkCommandPoolCreateFlags,
	queueFamilyIndex: u32,
}
impl VkCommandPoolCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferAllocateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	commandPool: VkCommandPool,
	level: VkCommandBufferLevel,
	commandBufferCount: u32,
}
impl VkCommandBufferAllocateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferInheritanceInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	renderPass: VkRenderPass,
	subpass: u32,
	framebuffer: VkFramebuffer,
	occlusionQueryEnable: VkBool32,
	queryFlags: VkQueryControlFlags,
	pipelineStatistics: VkQueryPipelineStatisticFlags,
}
impl VkCommandBufferInheritanceInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferBeginInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkCommandBufferUsageFlags,
	pInheritanceInfo: * const VkCommandBufferInheritanceInfo,
}
impl VkCommandBufferBeginInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassBeginInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	renderPass: VkRenderPass,
	framebuffer: VkFramebuffer,
	renderArea: VkRect2D,
	clearValueCount: u32,
	pClearValues: * const VkClearValue,
}
impl VkRenderPassBeginInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearDepthStencilValue
{
	depth: f32,
	stencil: u32,
}
impl VkClearDepthStencilValue
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearAttachment
{
	aspectMask: VkImageAspectFlags,
	colorAttachment: u32,
	clearValue: VkClearValue,
}
impl VkClearAttachment
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentDescription
{
	flags: VkAttachmentDescriptionFlags,
	format: VkFormat,
	samples: VkSampleCountFlagBits,
	loadOp: VkAttachmentLoadOp,
	storeOp: VkAttachmentStoreOp,
	stencilLoadOp: VkAttachmentLoadOp,
	stencilStoreOp: VkAttachmentStoreOp,
	initialLayout: VkImageLayout,
	finalLayout: VkImageLayout,
}
impl VkAttachmentDescription
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentReference
{
	attachment: u32,
	layout: VkImageLayout,
}
impl VkAttachmentReference
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescription
{
	flags: VkSubpassDescriptionFlags,
	pipelineBindPoint: VkPipelineBindPoint,
	inputAttachmentCount: u32,
	pInputAttachments: * const VkAttachmentReference,
	colorAttachmentCount: u32,
	pColorAttachments: * const VkAttachmentReference,
	pResolveAttachments: * const VkAttachmentReference,
	pDepthStencilAttachment: * const VkAttachmentReference,
	preserveAttachmentCount: u32,
	pPreserveAttachments: * const u32,
}
impl VkSubpassDescription
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDependency
{
	srcSubpass: u32,
	dstSubpass: u32,
	srcStageMask: VkPipelineStageFlags,
	dstStageMask: VkPipelineStageFlags,
	srcAccessMask: VkAccessFlags,
	dstAccessMask: VkAccessFlags,
	dependencyFlags: VkDependencyFlags,
}
impl VkSubpassDependency
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkRenderPassCreateFlags,
	attachmentCount: u32,
	pAttachments: * const VkAttachmentDescription,
	subpassCount: u32,
	pSubpasses: * const VkSubpassDescription,
	dependencyCount: u32,
	pDependencies: * const VkSubpassDependency,
}
impl VkRenderPassCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkEventCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkEventCreateFlags,
}
impl VkEventCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFenceCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkFenceCreateFlags,
}
impl VkFenceCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceFeatures
{
	robustBufferAccess: VkBool32,
	fullDrawIndexUint32: VkBool32,
	imageCubeArray: VkBool32,
	independentBlend: VkBool32,
	geometryShader: VkBool32,
	tessellationShader: VkBool32,
	sampleRateShading: VkBool32,
	dualSrcBlend: VkBool32,
	logicOp: VkBool32,
	multiDrawIndirect: VkBool32,
	drawIndirectFirstInstance: VkBool32,
	depthClamp: VkBool32,
	depthBiasClamp: VkBool32,
	fillModeNonSolid: VkBool32,
	depthBounds: VkBool32,
	wideLines: VkBool32,
	largePoints: VkBool32,
	alphaToOne: VkBool32,
	multiViewport: VkBool32,
	samplerAnisotropy: VkBool32,
	textureCompressionETC2: VkBool32,
	textureCompressionASTC_LDR: VkBool32,
	textureCompressionBC: VkBool32,
	occlusionQueryPrecise: VkBool32,
	pipelineStatisticsQuery: VkBool32,
	vertexPipelineStoresAndAtomics: VkBool32,
	fragmentStoresAndAtomics: VkBool32,
	shaderTessellationAndGeometryPointSize: VkBool32,
	shaderImageGatherExtended: VkBool32,
	shaderStorageImageExtendedFormats: VkBool32,
	shaderStorageImageMultisample: VkBool32,
	shaderStorageImageReadWithoutFormat: VkBool32,
	shaderStorageImageWriteWithoutFormat: VkBool32,
	shaderUniformBufferArrayDynamicIndexing: VkBool32,
	shaderSampledImageArrayDynamicIndexing: VkBool32,
	shaderStorageBufferArrayDynamicIndexing: VkBool32,
	shaderStorageImageArrayDynamicIndexing: VkBool32,
	shaderClipDistance: VkBool32,
	shaderCullDistance: VkBool32,
	shaderFloat64: VkBool32,
	shaderInt64: VkBool32,
	shaderInt16: VkBool32,
	shaderResourceResidency: VkBool32,
	shaderResourceMinLod: VkBool32,
	sparseBinding: VkBool32,
	sparseResidencyBuffer: VkBool32,
	sparseResidencyImage2D: VkBool32,
	sparseResidencyImage3D: VkBool32,
	sparseResidency2Samples: VkBool32,
	sparseResidency4Samples: VkBool32,
	sparseResidency8Samples: VkBool32,
	sparseResidency16Samples: VkBool32,
	sparseResidencyAliased: VkBool32,
	variableMultisampleRate: VkBool32,
	inheritedQueries: VkBool32,
}
impl VkPhysicalDeviceFeatures
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSparseProperties
{
	residencyStandard2DBlockShape: VkBool32,
	residencyStandard2DMultisampleBlockShape: VkBool32,
	residencyStandard3DBlockShape: VkBool32,
	residencyAlignedMipSize: VkBool32,
	residencyNonResidentStrict: VkBool32,
}
impl VkPhysicalDeviceSparseProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceLimits
{
	maxImageDimension1D: u32,
	maxImageDimension2D: u32,
	maxImageDimension3D: u32,
	maxImageDimensionCube: u32,
	maxImageArrayLayers: u32,
	maxTexelBufferElements: u32,
	maxUniformBufferRange: u32,
	maxStorageBufferRange: u32,
	maxPushConstantsSize: u32,
	maxMemoryAllocationCount: u32,
	maxSamplerAllocationCount: u32,
	bufferImageGranularity: VkDeviceSize,
	sparseAddressSpaceSize: VkDeviceSize,
	maxBoundDescriptorSets: u32,
	maxPerStageDescriptorSamplers: u32,
	maxPerStageDescriptorUniformBuffers: u32,
	maxPerStageDescriptorStorageBuffers: u32,
	maxPerStageDescriptorSampledImages: u32,
	maxPerStageDescriptorStorageImages: u32,
	maxPerStageDescriptorInputAttachments: u32,
	maxPerStageResources: u32,
	maxDescriptorSetSamplers: u32,
	maxDescriptorSetUniformBuffers: u32,
	maxDescriptorSetUniformBuffersDynamic: u32,
	maxDescriptorSetStorageBuffers: u32,
	maxDescriptorSetStorageBuffersDynamic: u32,
	maxDescriptorSetSampledImages: u32,
	maxDescriptorSetStorageImages: u32,
	maxDescriptorSetInputAttachments: u32,
	maxVertexInputAttributes: u32,
	maxVertexInputBindings: u32,
	maxVertexInputAttributeOffset: u32,
	maxVertexInputBindingStride: u32,
	maxVertexOutputComponents: u32,
	maxTessellationGenerationLevel: u32,
	maxTessellationPatchSize: u32,
	maxTessellationControlPerVertexInputComponents: u32,
	maxTessellationControlPerVertexOutputComponents: u32,
	maxTessellationControlPerPatchOutputComponents: u32,
	maxTessellationControlTotalOutputComponents: u32,
	maxTessellationEvaluationInputComponents: u32,
	maxTessellationEvaluationOutputComponents: u32,
	maxGeometryShaderInvocations: u32,
	maxGeometryInputComponents: u32,
	maxGeometryOutputComponents: u32,
	maxGeometryOutputVertices: u32,
	maxGeometryTotalOutputComponents: u32,
	maxFragmentInputComponents: u32,
	maxFragmentOutputAttachments: u32,
	maxFragmentDualSrcAttachments: u32,
	maxFragmentCombinedOutputResources: u32,
	maxComputeSharedMemorySize: u32,
	maxComputeWorkGroupCount: u32,
	maxComputeWorkGroupInvocations: u32,
	maxComputeWorkGroupSize: u32,
	subPixelPrecisionBits: u32,
	subTexelPrecisionBits: u32,
	mipmapPrecisionBits: u32,
	maxDrawIndexedIndexValue: u32,
	maxDrawIndirectCount: u32,
	maxSamplerLodBias: f32,
	maxSamplerAnisotropy: f32,
	maxViewports: u32,
	maxViewportDimensions: u32,
	viewportBoundsRange: f32,
	viewportSubPixelBits: u32,
	minMemoryMapAlignment: size_t,
	minTexelBufferOffsetAlignment: VkDeviceSize,
	minUniformBufferOffsetAlignment: VkDeviceSize,
	minStorageBufferOffsetAlignment: VkDeviceSize,
	minTexelOffset: i32,
	maxTexelOffset: u32,
	minTexelGatherOffset: i32,
	maxTexelGatherOffset: u32,
	minInterpolationOffset: f32,
	maxInterpolationOffset: f32,
	subPixelInterpolationOffsetBits: u32,
	maxFramebufferWidth: u32,
	maxFramebufferHeight: u32,
	maxFramebufferLayers: u32,
	framebufferColorSampleCounts: VkSampleCountFlags,
	framebufferDepthSampleCounts: VkSampleCountFlags,
	framebufferStencilSampleCounts: VkSampleCountFlags,
	framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
	maxColorAttachments: u32,
	sampledImageColorSampleCounts: VkSampleCountFlags,
	sampledImageIntegerSampleCounts: VkSampleCountFlags,
	sampledImageDepthSampleCounts: VkSampleCountFlags,
	sampledImageStencilSampleCounts: VkSampleCountFlags,
	storageImageSampleCounts: VkSampleCountFlags,
	maxSampleMaskWords: u32,
	timestampComputeAndGraphics: VkBool32,
	timestampPeriod: f32,
	maxClipDistances: u32,
	maxCullDistances: u32,
	maxCombinedClipAndCullDistances: u32,
	discreteQueuePriorities: u32,
	pointSizeRange: f32,
	lineWidthRange: f32,
	pointSizeGranularity: f32,
	lineWidthGranularity: f32,
	strictLines: VkBool32,
	standardSampleLocations: VkBool32,
	optimalBufferCopyOffsetAlignment: VkDeviceSize,
	optimalBufferCopyRowPitchAlignment: VkDeviceSize,
	nonCoherentAtomSize: VkDeviceSize,
}
impl VkPhysicalDeviceLimits
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkSemaphoreCreateFlags,
}
impl VkSemaphoreCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueryPoolCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkQueryPoolCreateFlags,
	queryType: VkQueryType,
	queryCount: u32,
	pipelineStatistics: VkQueryPipelineStatisticFlags,
}
impl VkQueryPoolCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkFramebufferCreateFlags,
	renderPass: VkRenderPass,
	attachmentCount: u32,
	pAttachments: * const VkImageView,
	width: u32,
	height: u32,
	layers: u32,
}
impl VkFramebufferCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDrawIndirectCommand
{
	vertexCount: u32,
	instanceCount: u32,
	firstVertex: u32,
	firstInstance: u32,
}
impl VkDrawIndirectCommand
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDrawIndexedIndirectCommand
{
	indexCount: u32,
	instanceCount: u32,
	firstIndex: u32,
	vertexOffset: i32,
	firstInstance: u32,
}
impl VkDrawIndexedIndirectCommand
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDispatchIndirectCommand
{
	x: u32,
	y: u32,
	z: u32,
}
impl VkDispatchIndirectCommand
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMultiDrawInfoEXT
{
	firstVertex: u32,
	vertexCount: u32,
}
impl VkMultiDrawInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMultiDrawIndexedInfoEXT
{
	firstIndex: u32,
	indexCount: u32,
	vertexOffset: i32,
}
impl VkMultiDrawIndexedInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubmitInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	waitSemaphoreCount: u32,
	pWaitSemaphores: * const VkSemaphore,
	pWaitDstStageMask: * const VkPipelineStageFlags,
	commandBufferCount: u32,
	pCommandBuffers: * const VkCommandBuffer,
	signalSemaphoreCount: u32,
	pSignalSemaphores: * const VkSemaphore,
}
impl VkSubmitInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPropertiesKHR
{
	display: VkDisplayKHR,
	displayName: * const c_char,
	physicalDimensions: VkExtent2D,
	physicalResolution: VkExtent2D,
	supportedTransforms: VkSurfaceTransformFlagsKHR,
	planeReorderPossible: VkBool32,
	persistentContent: VkBool32,
}
impl VkDisplayPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPlanePropertiesKHR
{
	currentDisplay: VkDisplayKHR,
	currentStackIndex: u32,
}
impl VkDisplayPlanePropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayModeParametersKHR
{
	visibleRegion: VkExtent2D,
	refreshRate: u32,
}
impl VkDisplayModeParametersKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayModePropertiesKHR
{
	displayMode: VkDisplayModeKHR,
	parameters: VkDisplayModeParametersKHR,
}
impl VkDisplayModePropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayModeCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDisplayModeCreateFlagsKHR,
	parameters: VkDisplayModeParametersKHR,
}
impl VkDisplayModeCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPlaneCapabilitiesKHR
{
	supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
	minSrcPosition: VkOffset2D,
	maxSrcPosition: VkOffset2D,
	minSrcExtent: VkExtent2D,
	maxSrcExtent: VkExtent2D,
	minDstPosition: VkOffset2D,
	maxDstPosition: VkOffset2D,
	minDstExtent: VkExtent2D,
	maxDstExtent: VkExtent2D,
}
impl VkDisplayPlaneCapabilitiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplaySurfaceCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDisplaySurfaceCreateFlagsKHR,
	displayMode: VkDisplayModeKHR,
	planeIndex: u32,
	planeStackIndex: u32,
	transform: VkSurfaceTransformFlagBitsKHR,
	globalAlpha: f32,
	alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
	imageExtent: VkExtent2D,
}
impl VkDisplaySurfaceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSurfaceCapabilitiesKHR
{
	minImageCount: u32,
	maxImageCount: u32,
	currentExtent: VkExtent2D,
	minImageExtent: VkExtent2D,
	maxImageExtent: VkExtent2D,
	maxImageArrayLayers: u32,
	supportedTransforms: VkSurfaceTransformFlagsKHR,
	currentTransform: VkSurfaceTransformFlagBitsKHR,
	supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
	supportedUsageFlags: VkImageUsageFlags,
}
impl VkSurfaceCapabilitiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAndroidSurfaceCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkAndroidSurfaceCreateFlagsKHR,
	window: * const ANativeWindow,
}
impl VkAndroidSurfaceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkViSurfaceCreateInfoNN
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkViSurfaceCreateFlagsNN,
	window: * const c_void,
}
impl VkViSurfaceCreateInfoNN
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkWaylandSurfaceCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkWaylandSurfaceCreateFlagsKHR,
	display: * const wl_display,
	surface: * const wl_surface,
}
impl VkWaylandSurfaceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkWin32SurfaceCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkWin32SurfaceCreateFlagsKHR,
	hinstance: HINSTANCE,
	hwnd: HWND,
}
impl VkWin32SurfaceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkXlibSurfaceCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkXlibSurfaceCreateFlagsKHR,
	dpy: * const Display,
	window: Window,
}
impl VkXlibSurfaceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkXcbSurfaceCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkXcbSurfaceCreateFlagsKHR,
	connection: * const xcb_connection_t,
	window: xcb_window_t,
}
impl VkXcbSurfaceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDirectFBSurfaceCreateInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDirectFBSurfaceCreateFlagsEXT,
	dfb: * const IDirectFB,
	surface: * const IDirectFBSurface,
}
impl VkDirectFBSurfaceCreateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImagePipeSurfaceCreateInfoFUCHSIA
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkImagePipeSurfaceCreateFlagsFUCHSIA,
	imagePipeHandle: zx_handle_t,
}
impl VkImagePipeSurfaceCreateInfoFUCHSIA
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkStreamDescriptorSurfaceCreateInfoGGP
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkStreamDescriptorSurfaceCreateFlagsGGP,
	streamDescriptor: GgpStreamDescriptor,
}
impl VkStreamDescriptorSurfaceCreateInfoGGP
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkScreenSurfaceCreateInfoQNX
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkScreenSurfaceCreateFlagsQNX,
	context: * const _screen_context,
	window: * const _screen_window,
}
impl VkScreenSurfaceCreateInfoQNX
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSurfaceFormatKHR
{
	format: VkFormat,
	colorSpace: VkColorSpaceKHR,
}
impl VkSurfaceFormatKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSwapchainCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkSwapchainCreateFlagsKHR,
	surface: VkSurfaceKHR,
	minImageCount: u32,
	imageFormat: VkFormat,
	imageColorSpace: VkColorSpaceKHR,
	imageExtent: VkExtent2D,
	imageArrayLayers: u32,
	imageUsage: VkImageUsageFlags,
	imageSharingMode: VkSharingMode,
	queueFamilyIndexCount: u32,
	pQueueFamilyIndices: * const u32,
	preTransform: VkSurfaceTransformFlagBitsKHR,
	compositeAlpha: VkCompositeAlphaFlagBitsKHR,
	presentMode: VkPresentModeKHR,
	clipped: VkBool32,
	oldSwapchain: VkSwapchainKHR,
}
impl VkSwapchainCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPresentInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	waitSemaphoreCount: u32,
	pWaitSemaphores: * const VkSemaphore,
	swapchainCount: u32,
	pSwapchains: * const VkSwapchainKHR,
	pImageIndices: * const u32,
	pResults: * const VkResult,
}
impl VkPresentInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugMarkerObjectNameInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	objectType: VkDebugReportObjectTypeEXT,
	object: uint64_t,
	pObjectName: * const c_char,
}
impl VkDebugMarkerObjectNameInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugMarkerObjectTagInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	objectType: VkDebugReportObjectTypeEXT,
	object: uint64_t,
	tagName: uint64_t,
	tagSize: size_t,
	pTag: * const c_void,
}
impl VkDebugMarkerObjectTagInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugMarkerMarkerInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	pMarkerName: * const c_char,
	color: f32,
}
impl VkDebugMarkerMarkerInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalImageFormatPropertiesNV
{
	imageFormatProperties: VkImageFormatProperties,
	externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV,
	exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
	compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
impl VkExternalImageFormatPropertiesNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPrivateDataSlotCreateInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPrivateDataSlotCreateFlagsEXT,
}
impl VkPrivateDataSlotCreateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGraphicsShaderGroupCreateInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	stageCount: u32,
	pStages: * const VkPipelineShaderStageCreateInfo,
	pVertexInputState: * const VkPipelineVertexInputStateCreateInfo,
	pTessellationState: * const VkPipelineTessellationStateCreateInfo,
}
impl VkGraphicsShaderGroupCreateInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindShaderGroupIndirectCommandNV
{
	groupIndex: u32,
}
impl VkBindShaderGroupIndirectCommandNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindIndexBufferIndirectCommandNV
{
	bufferAddress: VkDeviceAddress,
	size: u32,
	indexType: VkIndexType,
}
impl VkBindIndexBufferIndirectCommandNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindVertexBufferIndirectCommandNV
{
	bufferAddress: VkDeviceAddress,
	size: u32,
	stride: u32,
}
impl VkBindVertexBufferIndirectCommandNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSetStateFlagsIndirectCommandNV
{
	data: u32,
}
impl VkSetStateFlagsIndirectCommandNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkIndirectCommandsStreamNV
{
	buffer: VkBuffer,
	offset: VkDeviceSize,
}
impl VkIndirectCommandsStreamNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkIndirectCommandsLayoutTokenNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	tokenType: VkIndirectCommandsTokenTypeNV,
	stream: u32,
	offset: u32,
	vertexBindingUnit: u32,
	vertexDynamicStride: VkBool32,
	pushconstantPipelineLayout: VkPipelineLayout,
	pushconstantShaderStageFlags: VkShaderStageFlags,
	pushconstantOffset: u32,
	pushconstantSize: u32,
	indirectStateFlags: VkIndirectStateFlagsNV,
	indexTypeCount: u32,
	pIndexTypes: * const VkIndexType,
	pIndexTypeValues: * const u32,
}
impl VkIndirectCommandsLayoutTokenNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkIndirectCommandsLayoutCreateInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkIndirectCommandsLayoutUsageFlagsNV,
	pipelineBindPoint: VkPipelineBindPoint,
	tokenCount: u32,
	pTokens: * const VkIndirectCommandsLayoutTokenNV,
	streamCount: u32,
	pStreamStrides: * const u32,
}
impl VkIndirectCommandsLayoutCreateInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeneratedCommandsInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	pipelineBindPoint: VkPipelineBindPoint,
	pipeline: VkPipeline,
	indirectCommandsLayout: VkIndirectCommandsLayoutNV,
	streamCount: u32,
	pStreams: * const VkIndirectCommandsStreamNV,
	sequencesCount: u32,
	preprocessBuffer: VkBuffer,
	preprocessOffset: VkDeviceSize,
	preprocessSize: VkDeviceSize,
	sequencesCountBuffer: VkBuffer,
	sequencesCountOffset: VkDeviceSize,
	sequencesIndexBuffer: VkBuffer,
	sequencesIndexOffset: VkDeviceSize,
}
impl VkGeneratedCommandsInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeneratedCommandsMemoryRequirementsInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	pipelineBindPoint: VkPipelineBindPoint,
	pipeline: VkPipeline,
	indirectCommandsLayout: VkIndirectCommandsLayoutNV,
	maxSequencesCount: u32,
}
impl VkGeneratedCommandsMemoryRequirementsInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceFeatures2KHR
{
}
impl VkPhysicalDeviceFeatures2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProperties2
{
	sType: VkStructureType,
	pNext: * const c_void,
	properties: VkPhysicalDeviceProperties,
}
impl VkPhysicalDeviceProperties2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProperties2KHR
{
}
impl VkPhysicalDeviceProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFormatProperties2
{
	sType: VkStructureType,
	pNext: * const c_void,
	formatProperties: VkFormatProperties,
}
impl VkFormatProperties2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFormatProperties2KHR
{
}
impl VkFormatProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageFormatProperties2
{
	sType: VkStructureType,
	pNext: * const c_void,
	imageFormatProperties: VkImageFormatProperties,
}
impl VkImageFormatProperties2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageFormatProperties2KHR
{
}
impl VkImageFormatProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceImageFormatInfo2
{
	sType: VkStructureType,
	pNext: * const c_void,
	format: VkFormat,
	type: VkImageType,
	tiling: VkImageTiling,
	usage: VkImageUsageFlags,
	flags: VkImageCreateFlags,
}
impl VkPhysicalDeviceImageFormatInfo2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceImageFormatInfo2KHR
{
}
impl VkPhysicalDeviceImageFormatInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueueFamilyProperties2
{
	sType: VkStructureType,
	pNext: * const c_void,
	queueFamilyProperties: VkQueueFamilyProperties,
}
impl VkQueueFamilyProperties2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueueFamilyProperties2KHR
{
}
impl VkQueueFamilyProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties2
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryProperties: VkPhysicalDeviceMemoryProperties,
}
impl VkPhysicalDeviceMemoryProperties2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties2KHR
{
}
impl VkPhysicalDeviceMemoryProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageFormatProperties2
{
	sType: VkStructureType,
	pNext: * const c_void,
	properties: VkSparseImageFormatProperties,
}
impl VkSparseImageFormatProperties2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageFormatProperties2KHR
{
}
impl VkSparseImageFormatProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2
{
	sType: VkStructureType,
	pNext: * const c_void,
	format: VkFormat,
	type: VkImageType,
	samples: VkSampleCountFlagBits,
	usage: VkImageUsageFlags,
	tiling: VkImageTiling,
}
impl VkPhysicalDeviceSparseImageFormatInfo2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2KHR
{
}
impl VkPhysicalDeviceSparseImageFormatInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkConformanceVersion
{
	major: u8,
	minor: u8,
	subminor: u8,
	patch: u8,
}
impl VkConformanceVersion
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkConformanceVersionKHR
{
}
impl VkConformanceVersionKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDriverPropertiesKHR
{
}
impl VkPhysicalDeviceDriverPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPresentRegionKHR
{
	rectangleCount: u32,
	pRectangles: * const VkRectLayerKHR,
}
impl VkPresentRegionKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRectLayerKHR
{
	offset: VkOffset2D,
	extent: VkExtent2D,
	layer: u32,
}
impl VkRectLayerKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVariablePointersFeaturesKHR
{
}
impl VkPhysicalDeviceVariablePointersFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVariablePointerFeaturesKHR
{
}
impl VkPhysicalDeviceVariablePointerFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVariablePointerFeatures
{
}
impl VkPhysicalDeviceVariablePointerFeatures
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalMemoryProperties
{
	externalMemoryFeatures: VkExternalMemoryFeatureFlags,
	exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags,
	compatibleHandleTypes: VkExternalMemoryHandleTypeFlags,
}
impl VkExternalMemoryProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalMemoryPropertiesKHR
{
}
impl VkExternalMemoryPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalImageFormatInfoKHR
{
}
impl VkPhysicalDeviceExternalImageFormatInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalImageFormatPropertiesKHR
{
}
impl VkExternalImageFormatPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalBufferInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkBufferCreateFlags,
	usage: VkBufferUsageFlags,
	handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl VkPhysicalDeviceExternalBufferInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalBufferInfoKHR
{
}
impl VkPhysicalDeviceExternalBufferInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalBufferProperties
{
	sType: VkStructureType,
	pNext: * const c_void,
	externalMemoryProperties: VkExternalMemoryProperties,
}
impl VkExternalBufferProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalBufferPropertiesKHR
{
}
impl VkExternalBufferPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceIDPropertiesKHR
{
}
impl VkPhysicalDeviceIDPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalMemoryImageCreateInfoKHR
{
}
impl VkExternalMemoryImageCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalMemoryBufferCreateInfoKHR
{
}
impl VkExternalMemoryBufferCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExportMemoryAllocateInfoKHR
{
}
impl VkExportMemoryAllocateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryZirconHandlePropertiesFUCHSIA
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryTypeBits: u32,
}
impl VkMemoryZirconHandlePropertiesFUCHSIA
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryGetZirconHandleInfoFUCHSIA
{
	sType: VkStructureType,
	pNext: * const c_void,
	memory: VkDeviceMemory,
	handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl VkMemoryGetZirconHandleInfoFUCHSIA
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryWin32HandlePropertiesKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryTypeBits: u32,
}
impl VkMemoryWin32HandlePropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryGetWin32HandleInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	memory: VkDeviceMemory,
	handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl VkMemoryGetWin32HandleInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryFdPropertiesKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryTypeBits: u32,
}
impl VkMemoryFdPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryGetFdInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	memory: VkDeviceMemory,
	handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl VkMemoryGetFdInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalSemaphoreInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
impl VkPhysicalDeviceExternalSemaphoreInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalSemaphoreInfoKHR
{
}
impl VkPhysicalDeviceExternalSemaphoreInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalSemaphoreProperties
{
	sType: VkStructureType,
	pNext: * const c_void,
	exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags,
	compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags,
	externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags,
}
impl VkExternalSemaphoreProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalSemaphorePropertiesKHR
{
}
impl VkExternalSemaphorePropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExportSemaphoreCreateInfoKHR
{
}
impl VkExportSemaphoreCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImportSemaphoreWin32HandleInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	semaphore: VkSemaphore,
	flags: VkSemaphoreImportFlags,
	handleType: VkExternalSemaphoreHandleTypeFlagBits,
	handle: HANDLE,
	name: LPCWSTR,
}
impl VkImportSemaphoreWin32HandleInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreGetWin32HandleInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	semaphore: VkSemaphore,
	handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
impl VkSemaphoreGetWin32HandleInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImportSemaphoreFdInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	semaphore: VkSemaphore,
	flags: VkSemaphoreImportFlags,
	handleType: VkExternalSemaphoreHandleTypeFlagBits,
	fd: int,
}
impl VkImportSemaphoreFdInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreGetFdInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	semaphore: VkSemaphore,
	handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
impl VkSemaphoreGetFdInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImportSemaphoreZirconHandleInfoFUCHSIA
{
	sType: VkStructureType,
	pNext: * const c_void,
	semaphore: VkSemaphore,
	flags: VkSemaphoreImportFlags,
	handleType: VkExternalSemaphoreHandleTypeFlagBits,
	zirconHandle: zx_handle_t,
}
impl VkImportSemaphoreZirconHandleInfoFUCHSIA
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreGetZirconHandleInfoFUCHSIA
{
	sType: VkStructureType,
	pNext: * const c_void,
	semaphore: VkSemaphore,
	handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
impl VkSemaphoreGetZirconHandleInfoFUCHSIA
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalFenceInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	handleType: VkExternalFenceHandleTypeFlagBits,
}
impl VkPhysicalDeviceExternalFenceInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceExternalFenceInfoKHR
{
}
impl VkPhysicalDeviceExternalFenceInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalFenceProperties
{
	sType: VkStructureType,
	pNext: * const c_void,
	exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags,
	compatibleHandleTypes: VkExternalFenceHandleTypeFlags,
	externalFenceFeatures: VkExternalFenceFeatureFlags,
}
impl VkExternalFenceProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalFencePropertiesKHR
{
}
impl VkExternalFencePropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExportFenceCreateInfoKHR
{
}
impl VkExportFenceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImportFenceWin32HandleInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	fence: VkFence,
	flags: VkFenceImportFlags,
	handleType: VkExternalFenceHandleTypeFlagBits,
	handle: HANDLE,
	name: LPCWSTR,
}
impl VkImportFenceWin32HandleInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFenceGetWin32HandleInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	fence: VkFence,
	handleType: VkExternalFenceHandleTypeFlagBits,
}
impl VkFenceGetWin32HandleInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImportFenceFdInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	fence: VkFence,
	flags: VkFenceImportFlags,
	handleType: VkExternalFenceHandleTypeFlagBits,
	fd: int,
}
impl VkImportFenceFdInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFenceGetFdInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	fence: VkFence,
	handleType: VkExternalFenceHandleTypeFlagBits,
}
impl VkFenceGetFdInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewFeaturesKHR
{
}
impl VkPhysicalDeviceMultiviewFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewPropertiesKHR
{
}
impl VkPhysicalDeviceMultiviewPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassMultiviewCreateInfoKHR
{
}
impl VkRenderPassMultiviewCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSurfaceCapabilities2EXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	minImageCount: u32,
	maxImageCount: u32,
	currentExtent: VkExtent2D,
	minImageExtent: VkExtent2D,
	maxImageExtent: VkExtent2D,
	maxImageArrayLayers: u32,
	supportedTransforms: VkSurfaceTransformFlagsKHR,
	currentTransform: VkSurfaceTransformFlagBitsKHR,
	supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
	supportedUsageFlags: VkImageUsageFlags,
	supportedSurfaceCounters: VkSurfaceCounterFlagsEXT,
}
impl VkSurfaceCapabilities2EXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPowerInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	powerState: VkDisplayPowerStateEXT,
}
impl VkDisplayPowerInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceEventInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	deviceEvent: VkDeviceEventTypeEXT,
}
impl VkDeviceEventInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayEventInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	displayEvent: VkDisplayEventTypeEXT,
}
impl VkDisplayEventInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceGroupProperties
{
	sType: VkStructureType,
	pNext: * const c_void,
	physicalDeviceCount: u32,
	physicalDevices: VkPhysicalDevice,
	subsetAllocation: VkBool32,
}
impl VkPhysicalDeviceGroupProperties
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceGroupPropertiesKHR
{
}
impl VkPhysicalDeviceGroupPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryAllocateFlagsInfoKHR
{
}
impl VkMemoryAllocateFlagsInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindBufferMemoryInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	buffer: VkBuffer,
	memory: VkDeviceMemory,
	memoryOffset: VkDeviceSize,
}
impl VkBindBufferMemoryInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindBufferMemoryInfoKHR
{
}
impl VkBindBufferMemoryInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindBufferMemoryDeviceGroupInfoKHR
{
}
impl VkBindBufferMemoryDeviceGroupInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindImageMemoryInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	image: VkImage,
	memory: VkDeviceMemory,
	memoryOffset: VkDeviceSize,
}
impl VkBindImageMemoryInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindImageMemoryInfoKHR
{
}
impl VkBindImageMemoryInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindImageMemoryDeviceGroupInfoKHR
{
}
impl VkBindImageMemoryDeviceGroupInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupRenderPassBeginInfoKHR
{
}
impl VkDeviceGroupRenderPassBeginInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupCommandBufferBeginInfoKHR
{
}
impl VkDeviceGroupCommandBufferBeginInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupSubmitInfoKHR
{
}
impl VkDeviceGroupSubmitInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupBindSparseInfoKHR
{
}
impl VkDeviceGroupBindSparseInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupPresentCapabilitiesKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	presentMask: u32,
	modes: VkDeviceGroupPresentModeFlagsKHR,
}
impl VkDeviceGroupPresentCapabilitiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAcquireNextImageInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	swapchain: VkSwapchainKHR,
	timeout: uint64_t,
	semaphore: VkSemaphore,
	fence: VkFence,
	deviceMask: u32,
}
impl VkAcquireNextImageInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupDeviceCreateInfoKHR
{
}
impl VkDeviceGroupDeviceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorUpdateTemplateEntry
{
	dstBinding: u32,
	dstArrayElement: u32,
	descriptorCount: u32,
	descriptorType: VkDescriptorType,
	offset: size_t,
	stride: size_t,
}
impl VkDescriptorUpdateTemplateEntry
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorUpdateTemplateEntryKHR
{
}
impl VkDescriptorUpdateTemplateEntryKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorUpdateTemplateCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDescriptorUpdateTemplateCreateFlags,
	descriptorUpdateEntryCount: u32,
	pDescriptorUpdateEntries: * const VkDescriptorUpdateTemplateEntry,
	templateType: VkDescriptorUpdateTemplateType,
	descriptorSetLayout: VkDescriptorSetLayout,
	pipelineBindPoint: VkPipelineBindPoint,
	pipelineLayout: VkPipelineLayout,
	set: u32,
}
impl VkDescriptorUpdateTemplateCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorUpdateTemplateCreateInfoKHR
{
}
impl VkDescriptorUpdateTemplateCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkXYColorEXT
{
	x: f32,
	y: f32,
}
impl VkXYColorEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkHdrMetadataEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	displayPrimaryRed: VkXYColorEXT,
	displayPrimaryGreen: VkXYColorEXT,
	displayPrimaryBlue: VkXYColorEXT,
	whitePoint: VkXYColorEXT,
	maxLuminance: f32,
	minLuminance: f32,
	maxContentLightLevel: f32,
	maxFrameAverageLightLevel: f32,
}
impl VkHdrMetadataEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_HDR_METADATA_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRefreshCycleDurationGOOGLE
{
	refreshDuration: uint64_t,
}
impl VkRefreshCycleDurationGOOGLE
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPastPresentationTimingGOOGLE
{
	presentID: u32,
	desiredPresentTime: uint64_t,
	actualPresentTime: uint64_t,
	earliestPresentTime: uint64_t,
	presentMargin: uint64_t,
}
impl VkPastPresentationTimingGOOGLE
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPresentTimeGOOGLE
{
	presentID: u32,
	desiredPresentTime: uint64_t,
}
impl VkPresentTimeGOOGLE
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkIOSSurfaceCreateInfoMVK
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkIOSSurfaceCreateFlagsMVK,
	pView: * const c_void,
}
impl VkIOSSurfaceCreateInfoMVK
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMacOSSurfaceCreateInfoMVK
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkMacOSSurfaceCreateFlagsMVK,
	pView: * const c_void,
}
impl VkMacOSSurfaceCreateInfoMVK
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMetalSurfaceCreateInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkMetalSurfaceCreateFlagsEXT,
	pLayer: * const CAMetalLayer,
}
impl VkMetalSurfaceCreateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkViewportWScalingNV
{
	xcoeff: f32,
	ycoeff: f32,
}
impl VkViewportWScalingNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkViewportSwizzleNV
{
	x: VkViewportCoordinateSwizzleNV,
	y: VkViewportCoordinateSwizzleNV,
	z: VkViewportCoordinateSwizzleNV,
	w: VkViewportCoordinateSwizzleNV,
}
impl VkViewportSwizzleNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInputAttachmentAspectReference
{
	subpass: u32,
	inputAttachmentIndex: u32,
	aspectMask: VkImageAspectFlags,
}
impl VkInputAttachmentAspectReference
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInputAttachmentAspectReferenceKHR
{
}
impl VkInputAttachmentAspectReferenceKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassInputAttachmentAspectCreateInfoKHR
{
}
impl VkRenderPassInputAttachmentAspectCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSurfaceInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	surface: VkSurfaceKHR,
}
impl VkPhysicalDeviceSurfaceInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSurfaceCapabilities2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	surfaceCapabilities: VkSurfaceCapabilitiesKHR,
}
impl VkSurfaceCapabilities2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSurfaceFormat2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	surfaceFormat: VkSurfaceFormatKHR,
}
impl VkSurfaceFormat2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayProperties2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	displayProperties: VkDisplayPropertiesKHR,
}
impl VkDisplayProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPlaneProperties2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	displayPlaneProperties: VkDisplayPlanePropertiesKHR,
}
impl VkDisplayPlaneProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayModeProperties2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	displayModeProperties: VkDisplayModePropertiesKHR,
}
impl VkDisplayModeProperties2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPlaneInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	mode: VkDisplayModeKHR,
	planeIndex: u32,
}
impl VkDisplayPlaneInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPlaneCapabilities2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	capabilities: VkDisplayPlaneCapabilitiesKHR,
}
impl VkDisplayPlaneCapabilities2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDevice16BitStorageFeaturesKHR
{
}
impl VkPhysicalDevice16BitStorageFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
{
}
impl VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferMemoryRequirementsInfo2
{
	sType: VkStructureType,
	pNext: * const c_void,
	buffer: VkBuffer,
}
impl VkBufferMemoryRequirementsInfo2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferMemoryRequirementsInfo2KHR
{
}
impl VkBufferMemoryRequirementsInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageMemoryRequirementsInfo2
{
	sType: VkStructureType,
	pNext: * const c_void,
	image: VkImage,
}
impl VkImageMemoryRequirementsInfo2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageMemoryRequirementsInfo2KHR
{
}
impl VkImageMemoryRequirementsInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSparseMemoryRequirementsInfo2
{
	sType: VkStructureType,
	pNext: * const c_void,
	image: VkImage,
}
impl VkImageSparseMemoryRequirementsInfo2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageSparseMemoryRequirementsInfo2KHR
{
}
impl VkImageSparseMemoryRequirementsInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryRequirements2
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryRequirements: VkMemoryRequirements,
}
impl VkMemoryRequirements2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryRequirements2KHR
{
}
impl VkMemoryRequirements2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryRequirements2
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryRequirements: VkSparseImageMemoryRequirements,
}
impl VkSparseImageMemoryRequirements2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryRequirements2KHR
{
}
impl VkSparseImageMemoryRequirements2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDevicePointClippingPropertiesKHR
{
}
impl VkPhysicalDevicePointClippingPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryDedicatedRequirementsKHR
{
}
impl VkMemoryDedicatedRequirementsKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryDedicatedAllocateInfoKHR
{
}
impl VkMemoryDedicatedAllocateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageViewUsageCreateInfoKHR
{
}
impl VkImageViewUsageCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineTessellationDomainOriginStateCreateInfoKHR
{
}
impl VkPipelineTessellationDomainOriginStateCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerYcbcrConversionInfoKHR
{
}
impl VkSamplerYcbcrConversionInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerYcbcrConversionCreateInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	format: VkFormat,
	ycbcrModel: VkSamplerYcbcrModelConversion,
	ycbcrRange: VkSamplerYcbcrRange,
	components: VkComponentMapping,
	xChromaOffset: VkChromaLocation,
	yChromaOffset: VkChromaLocation,
	chromaFilter: VkFilter,
	forceExplicitReconstruction: VkBool32,
}
impl VkSamplerYcbcrConversionCreateInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerYcbcrConversionCreateInfoKHR
{
}
impl VkSamplerYcbcrConversionCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindImagePlaneMemoryInfoKHR
{
}
impl VkBindImagePlaneMemoryInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImagePlaneMemoryRequirementsInfoKHR
{
}
impl VkImagePlaneMemoryRequirementsInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR
{
}
impl VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerYcbcrConversionImageFormatPropertiesKHR
{
}
impl VkSamplerYcbcrConversionImageFormatPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkConditionalRenderingBeginInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	buffer: VkBuffer,
	offset: VkDeviceSize,
	flags: VkConditionalRenderingFlagsEXT,
}
impl VkConditionalRenderingBeginInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceQueueInfo2
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDeviceQueueCreateFlags,
	queueFamilyIndex: u32,
	queueIndex: u32,
}
impl VkDeviceQueueInfo2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
{
}
impl VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSampleLocationEXT
{
	x: f32,
	y: f32,
}
impl VkSampleLocationEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentSampleLocationsEXT
{
	attachmentIndex: u32,
	sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
impl VkAttachmentSampleLocationsEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassSampleLocationsEXT
{
	subpassIndex: u32,
	sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
impl VkSubpassSampleLocationsEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMultisamplePropertiesEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	maxSampleLocationGridSize: VkExtent2D,
}
impl VkMultisamplePropertiesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerReductionModeCreateInfoEXT
{
}
impl VkSamplerReductionModeCreateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageFormatListCreateInfoKHR
{
}
impl VkImageFormatListCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkValidationCacheCreateInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkValidationCacheCreateFlagsEXT,
	initialDataSize: size_t,
	pInitialData: * const c_void,
}
impl VkValidationCacheCreateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMaintenance3PropertiesKHR
{
}
impl VkPhysicalDeviceMaintenance3PropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutSupport
{
	sType: VkStructureType,
	pNext: * const c_void,
	supported: VkBool32,
}
impl VkDescriptorSetLayoutSupport
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutSupportKHR
{
}
impl VkDescriptorSetLayoutSupportKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderDrawParameterFeatures
{
}
impl VkPhysicalDeviceShaderDrawParameterFeatures
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderFloat16Int8FeaturesKHR
{
}
impl VkPhysicalDeviceShaderFloat16Int8FeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceFloat16Int8FeaturesKHR
{
}
impl VkPhysicalDeviceFloat16Int8FeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceFloatControlsPropertiesKHR
{
}
impl VkPhysicalDeviceFloatControlsPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceHostQueryResetFeaturesEXT
{
}
impl VkPhysicalDeviceHostQueryResetFeaturesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkNativeBufferUsage2ANDROID
{
	consumer: uint64_t,
	producer: uint64_t,
}
impl VkNativeBufferUsage2ANDROID
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkNativeBufferANDROID
{
	sType: VkStructureType,
	pNext: * const c_void,
	handle: * const c_void,
	stride: int,
	format: int,
	usage: int,
	usage2: VkNativeBufferUsage2ANDROID,
}
impl VkNativeBufferANDROID
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSwapchainImageCreateInfoANDROID
{
	sType: VkStructureType,
	pNext: * const c_void,
	usage: VkSwapchainImageUsageFlagsANDROID,
}
impl VkSwapchainImageCreateInfoANDROID
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDevicePresentationPropertiesANDROID
{
	sType: VkStructureType,
	pNext: * const c_void,
	sharedImage: VkBool32,
}
impl VkPhysicalDevicePresentationPropertiesANDROID
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkShaderResourceUsageAMD
{
	numUsedVgprs: u32,
	numUsedSgprs: u32,
	ldsSizePerLocalWorkGroup: u32,
	ldsUsageSizeInBytes: size_t,
	scratchMemUsageInBytes: size_t,
}
impl VkShaderResourceUsageAMD
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkShaderStatisticsInfoAMD
{
	shaderStageMask: VkShaderStageFlags,
	resourceUsage: VkShaderResourceUsageAMD,
	numPhysicalVgprs: u32,
	numPhysicalSgprs: u32,
	numAvailableVgprs: u32,
	numAvailableSgprs: u32,
	computeWorkGroupSize: u32,
}
impl VkShaderStatisticsInfoAMD
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugUtilsObjectNameInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	objectType: VkObjectType,
	objectHandle: uint64_t,
	pObjectName: * const c_char,
}
impl VkDebugUtilsObjectNameInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugUtilsObjectTagInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	objectType: VkObjectType,
	objectHandle: uint64_t,
	tagName: uint64_t,
	tagSize: size_t,
	pTag: * const c_void,
}
impl VkDebugUtilsObjectTagInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugUtilsLabelEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	pLabelName: * const c_char,
	color: f32,
}
impl VkDebugUtilsLabelEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugUtilsMessengerCallbackDataEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDebugUtilsMessengerCallbackDataFlagsEXT,
	pMessageIdName: * const c_char,
	messageIdNumber: i32,
	pMessage: * const c_char,
	queueLabelCount: u32,
	pQueueLabels: * const VkDebugUtilsLabelEXT,
	cmdBufLabelCount: u32,
	pCmdBufLabels: * const VkDebugUtilsLabelEXT,
	objectCount: u32,
	pObjects: * const VkDebugUtilsObjectNameInfoEXT,
}
impl VkDebugUtilsMessengerCallbackDataEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceMemoryReportCallbackDataEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkDeviceMemoryReportFlagsEXT,
	type: VkDeviceMemoryReportEventTypeEXT,
	memoryObjectId: uint64_t,
	size: VkDeviceSize,
	objectType: VkObjectType,
	objectHandle: uint64_t,
	heapIndex: u32,
}
impl VkDeviceMemoryReportCallbackDataEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryHostPointerPropertiesEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryTypeBits: u32,
}
impl VkMemoryHostPointerPropertiesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCalibratedTimestampInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	timeDomain: VkTimeDomainEXT,
}
impl VkCalibratedTimestampInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorIndexingFeaturesEXT
{
}
impl VkPhysicalDeviceDescriptorIndexingFeaturesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorIndexingPropertiesEXT
{
}
impl VkPhysicalDeviceDescriptorIndexingPropertiesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutBindingFlagsCreateInfoEXT
{
}
impl VkDescriptorSetLayoutBindingFlagsCreateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetVariableDescriptorCountAllocateInfoEXT
{
}
impl VkDescriptorSetVariableDescriptorCountAllocateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetVariableDescriptorCountLayoutSupportEXT
{
}
impl VkDescriptorSetVariableDescriptorCountLayoutSupportEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentDescription2
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkAttachmentDescriptionFlags,
	format: VkFormat,
	samples: VkSampleCountFlagBits,
	loadOp: VkAttachmentLoadOp,
	storeOp: VkAttachmentStoreOp,
	stencilLoadOp: VkAttachmentLoadOp,
	stencilStoreOp: VkAttachmentStoreOp,
	initialLayout: VkImageLayout,
	finalLayout: VkImageLayout,
}
impl VkAttachmentDescription2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentDescription2KHR
{
}
impl VkAttachmentDescription2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentReference2
{
	sType: VkStructureType,
	pNext: * const c_void,
	attachment: u32,
	layout: VkImageLayout,
	aspectMask: VkImageAspectFlags,
}
impl VkAttachmentReference2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentReference2KHR
{
}
impl VkAttachmentReference2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescription2
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkSubpassDescriptionFlags,
	pipelineBindPoint: VkPipelineBindPoint,
	viewMask: u32,
	inputAttachmentCount: u32,
	pInputAttachments: * const VkAttachmentReference2,
	colorAttachmentCount: u32,
	pColorAttachments: * const VkAttachmentReference2,
	pResolveAttachments: * const VkAttachmentReference2,
	pDepthStencilAttachment: * const VkAttachmentReference2,
	preserveAttachmentCount: u32,
	pPreserveAttachments: * const u32,
}
impl VkSubpassDescription2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescription2KHR
{
}
impl VkSubpassDescription2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDependency2
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcSubpass: u32,
	dstSubpass: u32,
	srcStageMask: VkPipelineStageFlags,
	dstStageMask: VkPipelineStageFlags,
	srcAccessMask: VkAccessFlags,
	dstAccessMask: VkAccessFlags,
	dependencyFlags: VkDependencyFlags,
	viewOffset: i32,
}
impl VkSubpassDependency2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDependency2KHR
{
}
impl VkSubpassDependency2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassCreateInfo2
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkRenderPassCreateFlags,
	attachmentCount: u32,
	pAttachments: * const VkAttachmentDescription2,
	subpassCount: u32,
	pSubpasses: * const VkSubpassDescription2,
	dependencyCount: u32,
	pDependencies: * const VkSubpassDependency2,
	correlatedViewMaskCount: u32,
	pCorrelatedViewMasks: * const u32,
}
impl VkRenderPassCreateInfo2
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassCreateInfo2KHR
{
}
impl VkRenderPassCreateInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassBeginInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	contents: VkSubpassContents,
}
impl VkSubpassBeginInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassBeginInfoKHR
{
}
impl VkSubpassBeginInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassEndInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
}
impl VkSubpassEndInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_END_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassEndInfoKHR
{
}
impl VkSubpassEndInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceTimelineSemaphoreFeaturesKHR
{
}
impl VkPhysicalDeviceTimelineSemaphoreFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceTimelineSemaphorePropertiesKHR
{
}
impl VkPhysicalDeviceTimelineSemaphorePropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreTypeCreateInfoKHR
{
}
impl VkSemaphoreTypeCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkTimelineSemaphoreSubmitInfoKHR
{
}
impl VkTimelineSemaphoreSubmitInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreWaitInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkSemaphoreWaitFlags,
	semaphoreCount: u32,
	pSemaphores: * const VkSemaphore,
	pValues: * const uint64_t,
}
impl VkSemaphoreWaitInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreWaitInfoKHR
{
}
impl VkSemaphoreWaitInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreSignalInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	semaphore: VkSemaphore,
	value: uint64_t,
}
impl VkSemaphoreSignalInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreSignalInfoKHR
{
}
impl VkSemaphoreSignalInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVertexInputBindingDivisorDescriptionEXT
{
	binding: u32,
	divisor: u32,
}
impl VkVertexInputBindingDivisorDescriptionEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAndroidHardwareBufferPropertiesANDROID
{
	sType: VkStructureType,
	pNext: * const c_void,
	allocationSize: VkDeviceSize,
	memoryTypeBits: u32,
}
impl VkAndroidHardwareBufferPropertiesANDROID
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryGetAndroidHardwareBufferInfoANDROID
{
	sType: VkStructureType,
	pNext: * const c_void,
	memory: VkDeviceMemory,
}
impl VkMemoryGetAndroidHardwareBufferInfoANDROID
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDevice8BitStorageFeaturesKHR
{
}
impl VkPhysicalDevice8BitStorageFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
{
}
impl VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceShaderAtomicInt64FeaturesKHR
{
}
impl VkPhysicalDeviceShaderAtomicInt64FeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCheckpointDataNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	stage: VkPipelineStageFlagBits,
	pCheckpointMarker: * const c_void,
}
impl VkCheckpointDataNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDepthStencilResolvePropertiesKHR
{
}
impl VkPhysicalDeviceDepthStencilResolvePropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescriptionDepthStencilResolveKHR
{
}
impl VkSubpassDescriptionDepthStencilResolveKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkShadingRatePaletteNV
{
	shadingRatePaletteEntryCount: u32,
	pShadingRatePaletteEntries: * const VkShadingRatePaletteEntryNV,
}
impl VkShadingRatePaletteNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCoarseSampleLocationNV
{
	pixelX: u32,
	pixelY: u32,
	sample: u32,
}
impl VkCoarseSampleLocationNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCoarseSampleOrderCustomNV
{
	shadingRate: VkShadingRatePaletteEntryNV,
	sampleCount: u32,
	sampleLocationCount: u32,
	pSampleLocations: * const VkCoarseSampleLocationNV,
}
impl VkCoarseSampleOrderCustomNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDrawMeshTasksIndirectCommandNV
{
	taskCount: u32,
	firstTask: u32,
}
impl VkDrawMeshTasksIndirectCommandNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRayTracingShaderGroupCreateInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	type: VkRayTracingShaderGroupTypeKHR,
	generalShader: u32,
	closestHitShader: u32,
	anyHitShader: u32,
	intersectionShader: u32,
}
impl VkRayTracingShaderGroupCreateInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRayTracingShaderGroupCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	type: VkRayTracingShaderGroupTypeKHR,
	generalShader: u32,
	closestHitShader: u32,
	anyHitShader: u32,
	intersectionShader: u32,
	pShaderGroupCaptureReplayHandle: * const c_void,
}
impl VkRayTracingShaderGroupCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRayTracingPipelineCreateInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineCreateFlags,
	stageCount: u32,
	pStages: * const VkPipelineShaderStageCreateInfo,
	groupCount: u32,
	pGroups: * const VkRayTracingShaderGroupCreateInfoNV,
	maxRecursionDepth: u32,
	layout: VkPipelineLayout,
	basePipelineHandle: VkPipeline,
	basePipelineIndex: i32,
}
impl VkRayTracingPipelineCreateInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRayTracingPipelineCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPipelineCreateFlags,
	stageCount: u32,
	pStages: * const VkPipelineShaderStageCreateInfo,
	groupCount: u32,
	pGroups: * const VkRayTracingShaderGroupCreateInfoKHR,
	maxPipelineRayRecursionDepth: u32,
	pLibraryInfo: * const VkPipelineLibraryCreateInfoKHR,
	pLibraryInterface: * const VkRayTracingPipelineInterfaceCreateInfoKHR,
	pDynamicState: * const VkPipelineDynamicStateCreateInfo,
	layout: VkPipelineLayout,
	basePipelineHandle: VkPipeline,
	basePipelineIndex: i32,
}
impl VkRayTracingPipelineCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeometryTrianglesNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	vertexData: VkBuffer,
	vertexOffset: VkDeviceSize,
	vertexCount: u32,
	vertexStride: VkDeviceSize,
	vertexFormat: VkFormat,
	indexData: VkBuffer,
	indexOffset: VkDeviceSize,
	indexCount: u32,
	indexType: VkIndexType,
	transformData: VkBuffer,
	transformOffset: VkDeviceSize,
}
impl VkGeometryTrianglesNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeometryAABBNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	aabbData: VkBuffer,
	numAABBs: u32,
	stride: u32,
	offset: VkDeviceSize,
}
impl VkGeometryAABBNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeometryDataNV
{
	triangles: VkGeometryTrianglesNV,
	aabbs: VkGeometryAABBNV,
}
impl VkGeometryDataNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeometryNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	geometryType: VkGeometryTypeKHR,
	geometry: VkGeometryDataNV,
	flags: VkGeometryFlagsKHR,
}
impl VkGeometryNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_GEOMETRY_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	type: VkAccelerationStructureTypeNV,
	flags: VkBuildAccelerationStructureFlagsNV,
	instanceCount: u32,
	geometryCount: u32,
	pGeometries: * const VkGeometryNV,
}
impl VkAccelerationStructureInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureCreateInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	compactedSize: VkDeviceSize,
	info: VkAccelerationStructureInfoNV,
}
impl VkAccelerationStructureCreateInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindAccelerationStructureMemoryInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	accelerationStructure: VkAccelerationStructureNV,
	memory: VkDeviceMemory,
	memoryOffset: VkDeviceSize,
	deviceIndexCount: u32,
	pDeviceIndices: * const u32,
}
impl VkBindAccelerationStructureMemoryInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureMemoryRequirementsInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	type: VkAccelerationStructureMemoryRequirementsTypeNV,
	accelerationStructure: VkAccelerationStructureNV,
}
impl VkAccelerationStructureMemoryRequirementsInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkStridedDeviceAddressRegionKHR
{
	deviceAddress: VkDeviceAddress,
	stride: VkDeviceSize,
	size: VkDeviceSize,
}
impl VkStridedDeviceAddressRegionKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkTraceRaysIndirectCommandKHR
{
	width: u32,
	height: u32,
	depth: u32,
}
impl VkTraceRaysIndirectCommandKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDrmFormatModifierPropertiesEXT
{
	drmFormatModifier: uint64_t,
	drmFormatModifierPlaneCount: u32,
	drmFormatModifierTilingFeatures: VkFormatFeatureFlags,
}
impl VkDrmFormatModifierPropertiesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageDrmFormatModifierPropertiesEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	drmFormatModifier: uint64_t,
}
impl VkImageDrmFormatModifierPropertiesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageStencilUsageCreateInfoEXT
{
}
impl VkImageStencilUsageCreateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
{
}
impl VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
{
}
impl VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeaturesKHR
{
}
impl VkPhysicalDeviceBufferDeviceAddressFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceBufferAddressFeaturesEXT
{
}
impl VkPhysicalDeviceBufferAddressFeaturesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferDeviceAddressInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	buffer: VkBuffer,
}
impl VkBufferDeviceAddressInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferDeviceAddressInfoKHR
{
}
impl VkBufferDeviceAddressInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferDeviceAddressInfoEXT
{
}
impl VkBufferDeviceAddressInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferOpaqueCaptureAddressCreateInfoKHR
{
}
impl VkBufferOpaqueCaptureAddressCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceImagelessFramebufferFeaturesKHR
{
}
impl VkPhysicalDeviceImagelessFramebufferFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferAttachmentsCreateInfoKHR
{
}
impl VkFramebufferAttachmentsCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferAttachmentImageInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkImageCreateFlags,
	usage: VkImageUsageFlags,
	width: u32,
	height: u32,
	layerCount: u32,
	viewFormatCount: u32,
	pViewFormats: * const VkFormat,
}
impl VkFramebufferAttachmentImageInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferAttachmentImageInfoKHR
{
}
impl VkFramebufferAttachmentImageInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassAttachmentBeginInfoKHR
{
}
impl VkRenderPassAttachmentBeginInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCooperativeMatrixPropertiesNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	MSize: u32,
	NSize: u32,
	KSize: u32,
	AType: VkComponentTypeNV,
	BType: VkComponentTypeNV,
	CType: VkComponentTypeNV,
	DType: VkComponentTypeNV,
	scope: VkScopeNV,
}
impl VkCooperativeMatrixPropertiesNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageViewHandleInfoNVX
{
	sType: VkStructureType,
	pNext: * const c_void,
	imageView: VkImageView,
	descriptorType: VkDescriptorType,
	sampler: VkSampler,
}
impl VkImageViewHandleInfoNVX
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageViewAddressPropertiesNVX
{
	sType: VkStructureType,
	pNext: * const c_void,
	deviceAddress: VkDeviceAddress,
	size: VkDeviceSize,
}
impl VkImageViewAddressPropertiesNVX
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineCreationFeedbackEXT
{
	flags: VkPipelineCreationFeedbackFlagsEXT,
	duration: uint64_t,
}
impl VkPipelineCreationFeedbackEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceCounterKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	unit: VkPerformanceCounterUnitKHR,
	scope: VkPerformanceCounterScopeKHR,
	storage: VkPerformanceCounterStorageKHR,
	uuid: u8,
}
impl VkPerformanceCounterKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceCounterDescriptionKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkPerformanceCounterDescriptionFlagsKHR,
	name: c_char,
	category: c_char,
	description: c_char,
}
impl VkPerformanceCounterDescriptionKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAcquireProfilingLockInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkAcquireProfilingLockFlagsKHR,
	timeout: uint64_t,
}
impl VkAcquireProfilingLockInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkHeadlessSurfaceCreateInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkHeadlessSurfaceCreateFlagsEXT,
}
impl VkHeadlessSurfaceCreateInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferMixedSamplesCombinationNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	coverageReductionMode: VkCoverageReductionModeNV,
	rasterizationSamples: VkSampleCountFlagBits,
	depthStencilSamples: VkSampleCountFlags,
	colorSamples: VkSampleCountFlags,
}
impl VkFramebufferMixedSamplesCombinationNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceValueINTEL
{
	type: VkPerformanceValueTypeINTEL,
	data: VkPerformanceValueDataINTEL,
}
impl VkPerformanceValueINTEL
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInitializePerformanceApiInfoINTEL
{
	sType: VkStructureType,
	pNext: * const c_void,
	pUserData: * const c_void,
}
impl VkInitializePerformanceApiInfoINTEL
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueryPoolCreateInfoINTEL
{
}
impl VkQueryPoolCreateInfoINTEL
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceMarkerInfoINTEL
{
	sType: VkStructureType,
	pNext: * const c_void,
	marker: uint64_t,
}
impl VkPerformanceMarkerInfoINTEL
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceStreamMarkerInfoINTEL
{
	sType: VkStructureType,
	pNext: * const c_void,
	marker: u32,
}
impl VkPerformanceStreamMarkerInfoINTEL
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceOverrideInfoINTEL
{
	sType: VkStructureType,
	pNext: * const c_void,
	type: VkPerformanceOverrideTypeINTEL,
	enable: VkBool32,
	parameter: uint64_t,
}
impl VkPerformanceOverrideInfoINTEL
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceConfigurationAcquireInfoINTEL
{
	sType: VkStructureType,
	pNext: * const c_void,
	type: VkPerformanceConfigurationTypeINTEL,
}
impl VkPerformanceConfigurationAcquireInfoINTEL
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR
{
}
impl VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentReferenceStencilLayoutKHR
{
}
impl VkAttachmentReferenceStencilLayoutKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentDescriptionStencilLayoutKHR
{
}
impl VkAttachmentDescriptionStencilLayoutKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	pipeline: VkPipeline,
}
impl VkPipelineInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineExecutablePropertiesKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	stages: VkShaderStageFlags,
	name: c_char,
	description: c_char,
	subgroupSize: u32,
}
impl VkPipelineExecutablePropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineExecutableInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	pipeline: VkPipeline,
	executableIndex: u32,
}
impl VkPipelineExecutableInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineExecutableStatisticKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	name: c_char,
	description: c_char,
	format: VkPipelineExecutableStatisticFormatKHR,
	value: VkPipelineExecutableStatisticValueKHR,
}
impl VkPipelineExecutableStatisticKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineExecutableInternalRepresentationKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	name: c_char,
	description: c_char,
	isText: VkBool32,
	dataSize: size_t,
	pData: * const c_void,
}
impl VkPipelineExecutableInternalRepresentationKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryOpaqueCaptureAddressAllocateInfoKHR
{
}
impl VkMemoryOpaqueCaptureAddressAllocateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceMemoryOpaqueCaptureAddressInfo
{
	sType: VkStructureType,
	pNext: * const c_void,
	memory: VkDeviceMemory,
}
impl VkDeviceMemoryOpaqueCaptureAddressInfo
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceMemoryOpaqueCaptureAddressInfoKHR
{
}
impl VkDeviceMemoryOpaqueCaptureAddressInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceToolPropertiesEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	name: c_char,
	version: c_char,
	purposes: VkToolPurposeFlagsEXT,
	description: c_char,
	layer: c_char,
}
impl VkPhysicalDeviceToolPropertiesEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryTrianglesDataKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	vertexFormat: VkFormat,
	vertexData: VkDeviceOrHostAddressConstKHR,
	vertexStride: VkDeviceSize,
	maxVertex: u32,
	indexType: VkIndexType,
	indexData: VkDeviceOrHostAddressConstKHR,
	transformData: VkDeviceOrHostAddressConstKHR,
}
impl VkAccelerationStructureGeometryTrianglesDataKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryAabbsDataKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	data: VkDeviceOrHostAddressConstKHR,
	stride: VkDeviceSize,
}
impl VkAccelerationStructureGeometryAabbsDataKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryInstancesDataKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	arrayOfPointers: VkBool32,
	data: VkDeviceOrHostAddressConstKHR,
}
impl VkAccelerationStructureGeometryInstancesDataKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	geometryType: VkGeometryTypeKHR,
	geometry: VkAccelerationStructureGeometryDataKHR,
	flags: VkGeometryFlagsKHR,
}
impl VkAccelerationStructureGeometryKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureBuildGeometryInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	type: VkAccelerationStructureTypeKHR,
	flags: VkBuildAccelerationStructureFlagsKHR,
	mode: VkBuildAccelerationStructureModeKHR,
	srcAccelerationStructure: VkAccelerationStructureKHR,
	dstAccelerationStructure: VkAccelerationStructureKHR,
	geometryCount: u32,
	pGeometries: * const VkAccelerationStructureGeometryKHR,
	ppGeometries: * const * const VkAccelerationStructureGeometryKHR,
	scratchData: VkDeviceOrHostAddressKHR,
}
impl VkAccelerationStructureBuildGeometryInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureBuildRangeInfoKHR
{
	primitiveCount: u32,
	primitiveOffset: u32,
	firstVertex: u32,
	transformOffset: u32,
}
impl VkAccelerationStructureBuildRangeInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	createFlags: VkAccelerationStructureCreateFlagsKHR,
	buffer: VkBuffer,
	offset: VkDeviceSize,
	size: VkDeviceSize,
	type: VkAccelerationStructureTypeKHR,
	deviceAddress: VkDeviceAddress,
}
impl VkAccelerationStructureCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAabbPositionsKHR
{
	minX: f32,
	minY: f32,
	minZ: f32,
	maxX: f32,
	maxY: f32,
	maxZ: f32,
}
impl VkAabbPositionsKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAabbPositionsNV
{
}
impl VkAabbPositionsNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkTransformMatrixKHR
{
	matrix: f32,
}
impl VkTransformMatrixKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkTransformMatrixNV
{
}
impl VkTransformMatrixNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureInstanceKHR
{
	transform: VkTransformMatrixKHR,
	instanceCustomIndex: u32,
	mask: u32,
	instanceShaderBindingTableRecordOffset: u32,
	flags: VkGeometryInstanceFlagsKHR,
	accelerationStructureReference: uint64_t,
}
impl VkAccelerationStructureInstanceKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureInstanceNV
{
}
impl VkAccelerationStructureInstanceNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureDeviceAddressInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	accelerationStructure: VkAccelerationStructureKHR,
}
impl VkAccelerationStructureDeviceAddressInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureVersionInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	pVersionData: * const u8,
}
impl VkAccelerationStructureVersionInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyAccelerationStructureInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	src: VkAccelerationStructureKHR,
	dst: VkAccelerationStructureKHR,
	mode: VkCopyAccelerationStructureModeKHR,
}
impl VkCopyAccelerationStructureInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyAccelerationStructureToMemoryInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	src: VkAccelerationStructureKHR,
	dst: VkDeviceOrHostAddressKHR,
	mode: VkCopyAccelerationStructureModeKHR,
}
impl VkCopyAccelerationStructureToMemoryInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyMemoryToAccelerationStructureInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	src: VkDeviceOrHostAddressConstKHR,
	dst: VkAccelerationStructureKHR,
	mode: VkCopyAccelerationStructureModeKHR,
}
impl VkCopyMemoryToAccelerationStructureInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRayTracingPipelineInterfaceCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	maxPipelineRayPayloadSize: u32,
	maxPipelineRayHitAttributeSize: u32,
}
impl VkRayTracingPipelineInterfaceCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineLibraryCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	libraryCount: u32,
	pLibraries: * const VkPipeline,
}
impl VkPipelineLibraryCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferCopy2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcOffset: VkDeviceSize,
	dstOffset: VkDeviceSize,
	size: VkDeviceSize,
}
impl VkBufferCopy2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageCopy2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcSubresource: VkImageSubresourceLayers,
	srcOffset: VkOffset3D,
	dstSubresource: VkImageSubresourceLayers,
	dstOffset: VkOffset3D,
	extent: VkExtent3D,
}
impl VkImageCopy2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageBlit2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcSubresource: VkImageSubresourceLayers,
	srcOffsets: VkOffset3D,
	dstSubresource: VkImageSubresourceLayers,
	dstOffsets: VkOffset3D,
}
impl VkImageBlit2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferImageCopy2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	bufferOffset: VkDeviceSize,
	bufferRowLength: u32,
	bufferImageHeight: u32,
	imageSubresource: VkImageSubresourceLayers,
	imageOffset: VkOffset3D,
	imageExtent: VkExtent3D,
}
impl VkBufferImageCopy2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageResolve2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcSubresource: VkImageSubresourceLayers,
	srcOffset: VkOffset3D,
	dstSubresource: VkImageSubresourceLayers,
	dstOffset: VkOffset3D,
	extent: VkExtent3D,
}
impl VkImageResolve2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyBufferInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcBuffer: VkBuffer,
	dstBuffer: VkBuffer,
	regionCount: u32,
	pRegions: * const VkBufferCopy2KHR,
}
impl VkCopyBufferInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyImageInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcImage: VkImage,
	srcImageLayout: VkImageLayout,
	dstImage: VkImage,
	dstImageLayout: VkImageLayout,
	regionCount: u32,
	pRegions: * const VkImageCopy2KHR,
}
impl VkCopyImageInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBlitImageInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcImage: VkImage,
	srcImageLayout: VkImageLayout,
	dstImage: VkImage,
	dstImageLayout: VkImageLayout,
	regionCount: u32,
	pRegions: * const VkImageBlit2KHR,
	filter: VkFilter,
}
impl VkBlitImageInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyBufferToImageInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcBuffer: VkBuffer,
	dstImage: VkImage,
	dstImageLayout: VkImageLayout,
	regionCount: u32,
	pRegions: * const VkBufferImageCopy2KHR,
}
impl VkCopyBufferToImageInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyImageToBufferInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcImage: VkImage,
	srcImageLayout: VkImageLayout,
	dstBuffer: VkBuffer,
	regionCount: u32,
	pRegions: * const VkBufferImageCopy2KHR,
}
impl VkCopyImageToBufferInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkResolveImageInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcImage: VkImage,
	srcImageLayout: VkImageLayout,
	dstImage: VkImage,
	dstImageLayout: VkImageLayout,
	regionCount: u32,
	pRegions: * const VkImageResolve2KHR,
}
impl VkResolveImageInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShadingRateKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	sampleCounts: VkSampleCountFlags,
	fragmentSize: VkExtent2D,
}
impl VkPhysicalDeviceFragmentShadingRateKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureBuildSizesInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	accelerationStructureSize: VkDeviceSize,
	updateScratchSize: VkDeviceSize,
	buildScratchSize: VkDeviceSize,
}
impl VkAccelerationStructureBuildSizesInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMutableDescriptorTypeListVALVE
{
	descriptorTypeCount: u32,
	pDescriptorTypes: * const VkDescriptorType,
}
impl VkMutableDescriptorTypeListVALVE
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVertexInputBindingDescription2EXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	binding: u32,
	stride: u32,
	inputRate: VkVertexInputRate,
	divisor: u32,
}
impl VkVertexInputBindingDescription2EXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVertexInputAttributeDescription2EXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	location: u32,
	binding: u32,
	format: VkFormat,
	offset: u32,
}
impl VkVertexInputAttributeDescription2EXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageMemoryBarrier2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcStageMask: VkPipelineStageFlags2KHR,
	srcAccessMask: VkAccessFlags2KHR,
	dstStageMask: VkPipelineStageFlags2KHR,
	dstAccessMask: VkAccessFlags2KHR,
	oldLayout: VkImageLayout,
	newLayout: VkImageLayout,
	srcQueueFamilyIndex: u32,
	dstQueueFamilyIndex: u32,
	image: VkImage,
	subresourceRange: VkImageSubresourceRange,
}
impl VkImageMemoryBarrier2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferMemoryBarrier2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	srcStageMask: VkPipelineStageFlags2KHR,
	srcAccessMask: VkAccessFlags2KHR,
	dstStageMask: VkPipelineStageFlags2KHR,
	dstAccessMask: VkAccessFlags2KHR,
	srcQueueFamilyIndex: u32,
	dstQueueFamilyIndex: u32,
	buffer: VkBuffer,
	offset: VkDeviceSize,
	size: VkDeviceSize,
}
impl VkBufferMemoryBarrier2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDependencyInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	dependencyFlags: VkDependencyFlags,
	memoryBarrierCount: u32,
	pMemoryBarriers: * const VkMemoryBarrier2KHR,
	bufferMemoryBarrierCount: u32,
	pBufferMemoryBarriers: * const VkBufferMemoryBarrier2KHR,
	imageMemoryBarrierCount: u32,
	pImageMemoryBarriers: * const VkImageMemoryBarrier2KHR,
}
impl VkDependencyInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSemaphoreSubmitInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	semaphore: VkSemaphore,
	value: uint64_t,
	stageMask: VkPipelineStageFlags2KHR,
	deviceIndex: u32,
}
impl VkSemaphoreSubmitInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferSubmitInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	commandBuffer: VkCommandBuffer,
	deviceMask: u32,
}
impl VkCommandBufferSubmitInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubmitInfo2KHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkSubmitFlagsKHR,
	waitSemaphoreInfoCount: u32,
	pWaitSemaphoreInfos: * const VkSemaphoreSubmitInfoKHR,
	commandBufferInfoCount: u32,
	pCommandBufferInfos: * const VkCommandBufferSubmitInfoKHR,
	signalSemaphoreInfoCount: u32,
	pSignalSemaphoreInfos: * const VkSemaphoreSubmitInfoKHR,
}
impl VkSubmitInfo2KHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCheckpointData2NV
{
	sType: VkStructureType,
	pNext: * const c_void,
	stage: VkPipelineStageFlags2KHR,
	pCheckpointMarker: * const c_void,
}
impl VkCheckpointData2NV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVideoFormatInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	imageUsage: VkImageUsageFlags,
	pVideoProfiles: * const VkVideoProfilesKHR,
}
impl VkPhysicalDeviceVideoFormatInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoFormatPropertiesKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	format: VkFormat,
}
impl VkVideoFormatPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoCapabilitiesKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	capabilityFlags: VkVideoCapabilityFlagsKHR,
	minBitstreamBufferOffsetAlignment: VkDeviceSize,
	minBitstreamBufferSizeAlignment: VkDeviceSize,
	videoPictureExtentGranularity: VkExtent2D,
	minExtent: VkExtent2D,
	maxExtent: VkExtent2D,
	maxReferencePicturesSlotsCount: u32,
	maxReferencePicturesActiveCount: u32,
}
impl VkVideoCapabilitiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoGetMemoryPropertiesKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryBindIndex: u32,
	pMemoryRequirements: * const VkMemoryRequirements2,
}
impl VkVideoGetMemoryPropertiesKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoBindMemoryKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	memoryBindIndex: u32,
	memory: VkDeviceMemory,
	memoryOffset: VkDeviceSize,
	memorySize: VkDeviceSize,
}
impl VkVideoBindMemoryKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoPictureResourceKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	codedOffset: VkOffset2D,
	codedExtent: VkExtent2D,
	baseArrayLayer: u32,
	imageViewBinding: VkImageView,
}
impl VkVideoPictureResourceKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoReferenceSlotKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	slotIndex: i8,
	pPictureResource: * const VkVideoPictureResourceKHR,
}
impl VkVideoReferenceSlotKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkVideoDecodeFlagsKHR,
	codedOffset: VkOffset2D,
	codedExtent: VkExtent2D,
	srcBuffer: VkBuffer,
	srcBufferOffset: VkDeviceSize,
	srcBufferRange: VkDeviceSize,
	dstPictureResource: VkVideoPictureResourceKHR,
	pSetupReferenceSlot: * const VkVideoReferenceSlotKHR,
	referenceSlotCount: u32,
	pReferenceSlots: * const VkVideoReferenceSlotKHR,
}
impl VkVideoDecodeInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoSessionCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	queueFamilyIndex: u32,
	flags: VkVideoSessionCreateFlagsKHR,
	pVideoProfile: * const VkVideoProfileKHR,
	pictureFormat: VkFormat,
	maxCodedExtent: VkExtent2D,
	referencePicturesFormat: VkFormat,
	maxReferencePicturesSlotsCount: u32,
	maxReferencePicturesActiveCount: u32,
}
impl VkVideoSessionCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoSessionParametersCreateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	videoSessionParametersTemplate: VkVideoSessionParametersKHR,
	videoSession: VkVideoSessionKHR,
}
impl VkVideoSessionParametersCreateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoSessionParametersUpdateInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	updateSequenceCount: u32,
}
impl VkVideoSessionParametersUpdateInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoBeginCodingInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkVideoBeginCodingFlagsKHR,
	codecQualityPreset: VkVideoCodingQualityPresetFlagsKHR,
	videoSession: VkVideoSessionKHR,
	videoSessionParameters: VkVideoSessionParametersKHR,
	referenceSlotCount: u32,
	pReferenceSlots: * const VkVideoReferenceSlotKHR,
}
impl VkVideoBeginCodingInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEndCodingInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkVideoEndCodingFlagsKHR,
}
impl VkVideoEndCodingInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoCodingControlInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkVideoCodingControlFlagsKHR,
}
impl VkVideoCodingControlInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeInfoKHR
{
	sType: VkStructureType,
	pNext: * const c_void,
	flags: VkVideoEncodeFlagsKHR,
	qualityLevel: u32,
	codedExtent: VkExtent2D,
	dstBitstreamBuffer: VkBuffer,
	dstBitstreamBufferOffset: VkDeviceSize,
	dstBitstreamBufferMaxRange: VkDeviceSize,
	srcPictureResource: VkVideoPictureResourceKHR,
	pSetupReferenceSlot: * const VkVideoReferenceSlotKHR,
	referenceSlotCount: u32,
	pReferenceSlots: * const VkVideoReferenceSlotKHR,
}
impl VkVideoEncodeInfoKHR
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264DpbSlotInfoEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	slotIndex: i8,
	pStdPictureInfo: * const StdVideoEncodeH264PictureInfo,
}
impl VkVideoEncodeH264DpbSlotInfoEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264NaluSliceEXT
{
	sType: VkStructureType,
	pNext: * const c_void,
	pSliceHeaderStd: * const StdVideoEncodeH264SliceHeader,
	mbCount: u32,
	refFinalList0EntryCount: u8,
	pRefFinalList0Entries: * const VkVideoEncodeH264DpbSlotInfoEXT,
	refFinalList1EntryCount: u8,
	pRefFinalList1Entries: * const VkVideoEncodeH264DpbSlotInfoEXT,
	precedingNaluBytes: u32,
	minQp: u8,
	maxQp: u8,
}
impl VkVideoEncodeH264NaluSliceEXT
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_EXT;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCuModuleCreateInfoNVX
{
	sType: VkStructureType,
	pNext: * const c_void,
	dataSize: size_t,
	pData: * const c_void,
}
impl VkCuModuleCreateInfoNVX
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCuFunctionCreateInfoNVX
{
	sType: VkStructureType,
	pNext: * const c_void,
	module: VkCuModuleNVX,
	pName: * const c_char,
}
impl VkCuFunctionCreateInfoNVX
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCuLaunchInfoNVX
{
	sType: VkStructureType,
	pNext: * const c_void,
	function: VkCuFunctionNVX,
	gridDimX: u32,
	gridDimY: u32,
	gridDimZ: u32,
	blockDimX: u32,
	blockDimY: u32,
	blockDimZ: u32,
	sharedMemBytes: u32,
	paramCount: size_t,
	pParams: * const * const c_void,
	extraCount: size_t,
	pExtras: * const * const c_void,
}
impl VkCuLaunchInfoNVX
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX;

        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSRTDataNV
{
	sx: f32,
	a: f32,
	b: f32,
	pvx: f32,
	sy: f32,
	c: f32,
	pvy: f32,
	sz: f32,
	pvz: f32,
	qx: f32,
	qy: f32,
	qz: f32,
	qw: f32,
	tx: f32,
	ty: f32,
	tz: f32,
}
impl VkSRTDataNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureSRTMotionInstanceNV
{
	transformT0: VkSRTDataNV,
	transformT1: VkSRTDataNV,
	instanceCustomIndex: u32,
	mask: u32,
	instanceShaderBindingTableRecordOffset: u32,
	flags: VkGeometryInstanceFlagsKHR,
	accelerationStructureReference: uint64_t,
}
impl VkAccelerationStructureSRTMotionInstanceNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureMatrixMotionInstanceNV
{
	transformT0: VkTransformMatrixKHR,
	transformT1: VkTransformMatrixKHR,
	instanceCustomIndex: u32,
	mask: u32,
	instanceShaderBindingTableRecordOffset: u32,
	flags: VkGeometryInstanceFlagsKHR,
	accelerationStructureReference: uint64_t,
}
impl VkAccelerationStructureMatrixMotionInstanceNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureMotionInstanceNV
{
	type: VkAccelerationStructureMotionInstanceTypeNV,
	flags: VkAccelerationStructureMotionInstanceFlagsNV,
	data: VkAccelerationStructureMotionInstanceDataNV,
}
impl VkAccelerationStructureMotionInstanceNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        
        return s;
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMemoryGetRemoteAddressInfoNV
{
	sType: VkStructureType,
	pNext: * const c_void,
	memory: VkDeviceMemory,
	handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl VkMemoryGetRemoteAddressInfoNV
{
    fn new() -> Self
    {
        let mut s: Self = unsafe { mem::zeroed() };
        s.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV;

        return s;
    }
}

